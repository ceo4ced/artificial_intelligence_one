<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Recurrent Neural Networks Quiz</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 0; }
.nav-header { background: #2d3748; padding: 15px 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex; justify-content: space-between; align-items: center; }
.nav-header a { color: #90cdf4; text-decoration: none; font-weight: 600; font-size: 1.1em; }
.nav-title { color: #fff; font-size: 1.2em; font-weight: 700; }
.container { max-width: 900px; margin: 20px auto; background: #fff; border-radius: 15px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
h1 { text-align: center; color: #2d3748; font-size: 2.5em; margin-bottom: 15px; }
.subtitle { text-align: center; color: #666; margin-bottom: 30px; font-size: 1.1em; }
.question-card { background: #f8f9fa; padding: 25px; border-radius: 10px; margin: 20px 0; border-left: 4px solid #667eea; }
.question-card.answered-correct { border-left-color: #4CAF50; background: #f1f8f4; }
.question-card.answered-wrong { border-left-color: #f44336; background: #ffebee; }
.question-number { color: #667eea; font-weight: 600; margin-bottom: 10px; }
.question-text { font-size: 1.2em; color: #2d3748; margin-bottom: 20px; line-height: 1.6; }
.options { display: flex; flex-direction: column; gap: 12px; }
.option { background: #fff; padding: 15px 20px; border-radius: 8px; border: 2px solid #e0e0e0; cursor: pointer; transition: all 0.3s; }
.option:hover { border-color: #667eea; transform: translateX(5px); }
.option.selected { border-color: #667eea; background: #e3f2fd; }
.option.correct { border-color: #4CAF50; background: #c8e6c9; }
.option.wrong { border-color: #f44336; background: #ffcdd2; }
.option.disabled { cursor: not-allowed; opacity: 0.7; }
.explanation { margin-top: 15px; padding: 15px; background: #fff9c4; border-radius: 6px; border-left: 3px solid #fbc02d; display: none; }
.explanation.show { display: block; }
.explanation strong { color: #f57c00; }
.progress-bar { background: #e0e0e0; height: 10px; border-radius: 5px; margin: 20px 0; overflow: hidden; }
.progress-fill { background: linear-gradient(90deg, #667eea, #764ba2); height: 100%; transition: width 0.3s; }
.quiz-actions { display: flex; gap: 15px; justify-content: center; margin: 30px 0; }
button { padding: 15px 30px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1.05em; transition: all 0.3s; }
.btn-primary { background: #4CAF50; color: #fff; }
.btn-primary:hover { background: #45a049; transform: scale(1.05); }
.btn-primary:disabled { background: #ccc; cursor: not-allowed; transform: none; }
.btn-secondary { background: #2196F3; color: #fff; }
.btn-secondary:hover { background: #1976d2; }
.results-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; padding: 40px; border-radius: 15px; text-align: center; margin: 30px 0; }
.results-card h2 { font-size: 2.5em; margin-bottom: 20px; }
.score-display { font-size: 4em; font-weight: bold; margin: 20px 0; }
.results-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; margin: 30px 0; }
.result-stat { background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; }
.result-stat-value { font-size: 2em; font-weight: bold; }
.result-stat-label { margin-top: 8px; opacity: 0.9; }
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">Recurrent Neural Networks Quiz</div>
    <div>
        <a href="../../lessons/rnn/index.html" style="margin-right: 20px;">View Lesson</a>
        <a href="../index.html">Back to Quizzes</a>
    </div>
</nav>
<div class="container">
    <h1>Recurrent Neural Networks Quiz</h1>
    <p class="subtitle">Test your understanding of RNNs, hidden state, and sequence processing</p>

    <div class="progress-bar">
        <div class="progress-fill" id="progressBar" style="width: 0%"></div>
    </div>

    <div id="quizContent"></div>

    <div class="quiz-actions" id="quizActions">
        <button class="btn-primary" id="submitBtn" onclick="submitQuiz()" disabled>Submit Quiz</button>
        <button class="btn-secondary" onclick="retakeQuiz()">Retake Quiz</button>
    </div>
</div>

<script>
const quizData = {
    id: 'rnn',
    questions: [
        {
            question: "What is the key feature that distinguishes RNNs from feedforward networks?",
            options: [
                "They have more layers",
                "They have recurrent connections that create memory of previous inputs",
                "They process images better",
                "They train faster"
            ],
            correct: 1,
            explanation: "RNNs have recurrent connections that allow information to persist, creating a form of memory. This enables them to process sequential data by maintaining context from previous time steps."
        },
        {
            question: "What is the hidden state in an RNN?",
            options: [
                "A secret layer users can't see",
                "Internal memory that carries information from previous time steps",
                "An error in the network",
                "The final output layer"
            ],
            correct: 1,
            explanation: "The hidden state is the RNN's internal memory that carries information from previous time steps, allowing the network to maintain context and process sequences effectively."
        },
        {
            question: "How does an RNN process a sequence of inputs?",
            options: [
                "All at once in parallel",
                "One element at a time, updating hidden state at each step",
                "From end to beginning only",
                "By converting it to an image first"
            ],
            correct: 1,
            explanation: "RNNs process sequences one element at a time in order, updating the hidden state at each time step to incorporate new information while maintaining context from previous steps."
        },
        {
            question: "What type of data are RNNs particularly good at handling?",
            options: [
                "Static images",
                "Sequential data like text, time series, or speech",
                "Random numbers",
                "Spreadsheet data only"
            ],
            correct: 1,
            explanation: "RNNs excel at sequential data where order matters, such as text (word sequences), time series (temporal patterns), and speech (audio sequences over time)."
        },
        {
            question: "What is the vanishing gradient problem in RNNs?",
            options: [
                "The network disappears during training",
                "Gradients become very small over long sequences, making it hard to learn long-term dependencies",
                "The gradient increases too much",
                "The network runs out of memory"
            ],
            correct: 1,
            explanation: "In RNNs, gradients can become extremely small when backpropagating through many time steps, making it difficult to learn dependencies between events that are far apart in the sequence."
        },
        {
            question: "What is temporal dynamics in the context of RNNs?",
            options: [
                "How fast the network runs",
                "How patterns change and evolve over time in sequences",
                "The number of layers in the network",
                "The size of the training dataset"
            ],
            correct: 1,
            explanation: "Temporal dynamics refers to how patterns, relationships, and information change over time in sequential data. RNNs are designed to capture and model these time-dependent patterns."
        },
        {
            question: "Which application is well-suited for RNNs?",
            options: [
                "Sorting a list of numbers",
                "Language translation and next-word prediction",
                "Adding two numbers",
                "Displaying static images"
            ],
            correct: 1,
            explanation: "RNNs are excellent for language tasks like translation and next-word prediction because they can understand context and relationships between words in a sequence."
        },
        {
            question: "What happens to the hidden state as an RNN processes a sequence?",
            options: [
                "It stays constant",
                "It gets updated at each time step to incorporate new information",
                "It gets deleted after each word",
                "It only changes at the end"
            ],
            correct: 1,
            explanation: "The hidden state is updated at each time step, combining information from the current input with the previous hidden state, allowing the network to build up context."
        },
        {
            question: "Why are standard RNNs limited in learning very long sequences?",
            options: [
                "They run out of electricity",
                "The vanishing gradient problem prevents learning long-term dependencies",
                "They can only count to 100",
                "They don't have enough neurons"
            ],
            correct: 1,
            explanation: "Standard RNNs struggle with long sequences because of the vanishing gradient problem - gradients become too small to effectively update weights for connections spanning many time steps."
        },
        {
            question: "What is backpropagation through time (BPTT)?",
            options: [
                "Training the network in the past",
                "The algorithm for training RNNs by unrolling the network across time steps",
                "A time-traveling algorithm",
                "Deleting old training data"
            ],
            correct: 1,
            explanation: "Backpropagation through time (BPTT) is the training algorithm for RNNs that unrolls the network across all time steps and backpropagates errors through the sequence to update weights."
        },
        {
            question: "How does an RNN maintain context in a sentence?",
            options: [
                "By memorizing every word ever seen",
                "By passing information through the hidden state from word to word",
                "By looking ahead to the last word",
                "It doesn't maintain context"
            ],
            correct: 1,
            explanation: "RNNs maintain context by passing the hidden state from one time step to the next, allowing information about earlier words to influence the processing of later words."
        },
        {
            question: "What is one key advantage of RNNs over feedforward networks?",
            options: [
                "They are always faster",
                "They can handle variable-length sequences and maintain temporal context",
                "They never make errors",
                "They don't need training"
            ],
            correct: 1,
            explanation: "RNNs can process sequences of any length and maintain context across time steps through their recurrent connections, unlike feedforward networks that treat each input independently."
        }
    ]
};

let userAnswers = [];
let submitted = false;

function init() {
    loadQuiz();
    loadProgress();
}

function loadQuiz() {
    const content = document.getElementById('quizContent');
    content.innerHTML = quizData.questions.map((q, index) => `
        <div class="question-card" id="question${index}">
            <div class="question-number">Question ${index + 1} of ${quizData.questions.length}</div>
            <div class="question-text">${q.question}</div>
            <div class="options">
                ${q.options.map((option, optIndex) => `
                    <div class="option" onclick="selectOption(${index}, ${optIndex})" id="q${index}_opt${optIndex}">
                        ${option}
                    </div>
                `).join('')}
            </div>
            <div class="explanation" id="explanation${index}">
                <strong>Explanation:</strong> ${q.explanation}
            </div>
        </div>
    `).join('');
}

function selectOption(questionIndex, optionIndex) {
    if (submitted) return;

    // Clear previous selection
    for (let i = 0; i < quizData.questions[questionIndex].options.length; i++) {
        document.getElementById(`q${questionIndex}_opt${i}`).classList.remove('selected');
    }

    // Mark new selection
    document.getElementById(`q${questionIndex}_opt${optionIndex}`).classList.add('selected');
    userAnswers[questionIndex] = optionIndex;

    updateProgress();
    checkSubmitEnabled();
}

function checkSubmitEnabled() {
    const allAnswered = userAnswers.length === quizData.questions.length &&
                       userAnswers.every(a => a !== undefined);
    document.getElementById('submitBtn').disabled = !allAnswered;
}

function updateProgress() {
    const progress = (userAnswers.filter(a => a !== undefined).length / quizData.questions.length) * 100;
    document.getElementById('progressBar').style.width = progress + '%';
}

function submitQuiz() {
    if (submitted) return;
    submitted = true;

    let correct = 0;

    quizData.questions.forEach((q, index) => {
        const questionCard = document.getElementById(`question${index}`);
        const userAnswer = userAnswers[index];
        const isCorrect = userAnswer === q.correct;

        if (isCorrect) {
            correct++;
            questionCard.classList.add('answered-correct');
        } else {
            questionCard.classList.add('answered-wrong');
        }

        // Show correct/wrong on options
        q.options.forEach((_, optIndex) => {
            const optEl = document.getElementById(`q${index}_opt${optIndex}`);
            optEl.classList.add('disabled');

            if (optIndex === q.correct) {
                optEl.classList.add('correct');
            } else if (optIndex === userAnswer && !isCorrect) {
                optEl.classList.add('wrong');
            }
        });

        // Show explanation
        document.getElementById(`explanation${index}`).classList.add('show');
    });

    const percentage = Math.round((correct / quizData.questions.length) * 100);

    // Save result
    const result = {
        score: correct,
        total: quizData.questions.length,
        percentage: percentage,
        date: new Date().toISOString()
    };
    localStorage.setItem(`quiz_${quizData.id}`, JSON.stringify(result));

    // Show results
    showResults(correct, percentage);
}

function showResults(correct, percentage) {
    const content = document.getElementById('quizContent');
    let message = '';
    if (percentage >= 90) message = 'Excellent! You have mastered recurrent neural networks!';
    else if (percentage >= 70) message = 'Great job! You understand the key concepts!';
    else if (percentage >= 50) message = 'Good effort! Review the lesson to improve!';
    else message = 'Keep learning! Review the lesson and try again!';

    content.innerHTML = `
        <div class="results-card">
            <h2>Quiz Complete!</h2>
            <div class="score-display">${percentage}%</div>
            <p style="font-size: 1.3em; margin: 20px 0;">${message}</p>
            <div class="results-grid">
                <div class="result-stat">
                    <div class="result-stat-value">${correct}</div>
                    <div class="result-stat-label">Correct</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value">${quizData.questions.length - correct}</div>
                    <div class="result-stat-label">Incorrect</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value">${correct * 10}</div>
                    <div class="result-stat-label">Points Earned</div>
                </div>
            </div>
        </div>
    ` + content.innerHTML;

    document.getElementById('submitBtn').style.display = 'none';
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

function retakeQuiz() {
    if (confirm('Retake the quiz? Your previous score will be replaced.')) {
        userAnswers = [];
        submitted = false;
        document.getElementById('submitBtn').style.display = 'inline-block';
        init();
        updateProgress();
    }
}

function loadProgress() {
    // Could load previous answers here if needed
}

// Initialize
init();
</script>
</body>
</html>
