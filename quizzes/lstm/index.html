<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Long Short-Term Memory Quiz</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 0; }
.nav-header { background: #2d3748; padding: 15px 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex; justify-content: space-between; align-items: center; }
.nav-header a { color: #90cdf4; text-decoration: none; font-weight: 600; font-size: 1.1em; }
.nav-title { color: #fff; font-size: 1.2em; font-weight: 700; }
.container { max-width: 900px; margin: 20px auto; background: #fff; border-radius: 15px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
h1 { text-align: center; color: #2d3748; font-size: 2.5em; margin-bottom: 15px; }
.subtitle { text-align: center; color: #666; margin-bottom: 30px; font-size: 1.1em; }
.question-card { background: #f8f9fa; padding: 25px; border-radius: 10px; margin: 20px 0; border-left: 4px solid #667eea; }
.question-card.answered-correct { border-left-color: #4CAF50; background: #f1f8f4; }
.question-card.answered-wrong { border-left-color: #f44336; background: #ffebee; }
.question-number { color: #667eea; font-weight: 600; margin-bottom: 10px; }
.question-text { font-size: 1.2em; color: #2d3748; margin-bottom: 20px; line-height: 1.6; }
.options { display: flex; flex-direction: column; gap: 12px; }
.option { background: #fff; padding: 15px 20px; border-radius: 8px; border: 2px solid #e0e0e0; cursor: pointer; transition: all 0.3s; }
.option:hover { border-color: #667eea; transform: translateX(5px); }
.option.selected { border-color: #667eea; background: #e3f2fd; }
.option.correct { border-color: #4CAF50; background: #c8e6c9; }
.option.wrong { border-color: #f44336; background: #ffcdd2; }
.option.disabled { cursor: not-allowed; opacity: 0.7; }
.explanation { margin-top: 15px; padding: 15px; background: #fff9c4; border-radius: 6px; border-left: 3px solid #fbc02d; display: none; }
.explanation.show { display: block; }
.explanation strong { color: #f57c00; }
.progress-bar { background: #e0e0e0; height: 10px; border-radius: 5px; margin: 20px 0; overflow: hidden; }
.progress-fill { background: linear-gradient(90deg, #667eea, #764ba2); height: 100%; transition: width 0.3s; }
.quiz-actions { display: flex; gap: 15px; justify-content: center; margin: 30px 0; }
button { padding: 15px 30px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1.05em; transition: all 0.3s; }
.btn-primary { background: #4CAF50; color: #fff; }
.btn-primary:hover { background: #45a049; transform: scale(1.05); }
.btn-primary:disabled { background: #ccc; cursor: not-allowed; transform: none; }
.btn-secondary { background: #2196F3; color: #fff; }
.btn-secondary:hover { background: #1976d2; }
.results-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; padding: 40px; border-radius: 15px; text-align: center; margin: 30px 0; }
.results-card h2 { font-size: 2.5em; margin-bottom: 20px; }
.score-display { font-size: 4em; font-weight: bold; margin: 20px 0; }
.results-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; margin: 30px 0; }
.result-stat { background: rgba(255,255,255,0.2); padding: 20px; border-radius: 10px; }
.result-stat-value { font-size: 2em; font-weight: bold; }
.result-stat-label { margin-top: 8px; opacity: 0.9; }
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">Long Short-Term Memory Quiz</div>
    <div>
        <a href="../../lessons/lstm/index.html" style="margin-right: 20px;">View Lesson</a>
        <a href="../index.html">Back to Quizzes</a>
    </div>
</nav>
<div class="container">
    <h1>Long Short-Term Memory Quiz</h1>
    <p class="subtitle">Test your understanding of LSTM gates, cell state, and long-term dependencies</p>

    <div class="progress-bar">
        <div class="progress-fill" id="progressBar" style="width: 0%"></div>
    </div>

    <div id="quizContent"></div>

    <div class="quiz-actions" id="quizActions">
        <button class="btn-primary" id="submitBtn" onclick="submitQuiz()" disabled>Submit Quiz</button>
        <button class="btn-secondary" onclick="retakeQuiz()">Retake Quiz</button>
    </div>
</div>

<script>
const quizData = {
    id: 'lstm',
    questions: [
        {
            question: "What problem were LSTMs specifically designed to solve?",
            options: [
                "Making networks faster",
                "The vanishing gradient problem in standard RNNs",
                "Reducing memory usage",
                "Processing images better"
            ],
            correct: 1,
            explanation: "LSTMs were designed to solve the vanishing gradient problem that prevents standard RNNs from learning long-term dependencies in sequences."
        },
        {
            question: "What is the cell state in an LSTM?",
            options: [
                "The current battery level",
                "A memory highway that carries information across many time steps",
                "The final output",
                "The input data"
            ],
            correct: 1,
            explanation: "The cell state is like a conveyor belt that runs through the entire sequence, allowing information to flow unchanged across many time steps, enabling long-term memory."
        },
        {
            question: "How many gates does an LSTM cell have?",
            options: [
                "One gate",
                "Three gates: forget gate, input gate, and output gate",
                "No gates",
                "Five gates"
            ],
            correct: 1,
            explanation: "LSTMs have three gates that control information flow: the forget gate (what to discard), input gate (what to add), and output gate (what to output)."
        },
        {
            question: "What is the purpose of the forget gate?",
            options: [
                "To erase all memory",
                "To decide what information from the cell state should be discarded",
                "To remember everything",
                "To generate output"
            ],
            correct: 1,
            explanation: "The forget gate decides which information in the cell state is no longer relevant and should be forgotten, outputting values between 0 (forget completely) and 1 (keep completely)."
        },
        {
            question: "What does the input gate do?",
            options: [
                "Accepts user input",
                "Decides what new information should be added to the cell state",
                "Closes the network",
                "Deletes old data"
            ],
            correct: 1,
            explanation: "The input gate determines which new information from the current input and hidden state should be stored in the cell state, controlling what gets learned."
        },
        {
            question: "What is the role of the output gate?",
            options: [
                "To turn off the network",
                "To decide what information from the cell state should be output",
                "To delete the output",
                "To compress data"
            ],
            correct: 1,
            explanation: "The output gate controls what parts of the cell state should be output as the hidden state at the current time step, filtering the cell state information."
        },
        {
            question: "How do LSTMs solve the vanishing gradient problem?",
            options: [
                "By making the network smaller",
                "By maintaining a cell state with mostly additive operations, preserving gradients",
                "By training slower",
                "By removing all gradients"
            ],
            correct: 1,
            explanation: "LSTMs solve vanishing gradients through the cell state, which uses mostly additive operations rather than repeated multiplications, allowing gradients to flow back through many time steps."
        },
        {
            question: "What makes LSTMs better than standard RNNs for long sequences?",
            options: [
                "They are faster",
                "They can learn and remember long-term dependencies through gated memory",
                "They use less memory",
                "They don't need training"
            ],
            correct: 1,
            explanation: "LSTMs excel at long sequences because their gated architecture allows them to selectively remember important information over many time steps and forget irrelevant information."
        },
        {
            question: "What type of activation function is typically used in LSTM gates?",
            options: [
                "ReLU only",
                "Sigmoid function (outputs values between 0 and 1)",
                "Linear function",
                "Step function"
            ],
            correct: 1,
            explanation: "LSTM gates typically use the sigmoid activation function because it outputs values between 0 and 1, which can be interpreted as percentages of how much information to let through."
        },
        {
            question: "Which application benefits most from LSTMs?",
            options: [
                "Static image classification",
                "Language modeling, machine translation, and time series prediction",
                "Simple arithmetic",
                "Data sorting"
            ],
            correct: 1,
            explanation: "LSTMs excel at tasks requiring long-term memory like language modeling (understanding context over sentences), machine translation (maintaining meaning across languages), and time series prediction."
        },
        {
            question: "What happens in the cell state update step?",
            options: [
                "Everything is deleted",
                "Old information is selectively forgotten and new information is added",
                "Nothing changes",
                "Data is compressed"
            ],
            correct: 1,
            explanation: "During cell state update, the forget gate removes irrelevant information and the input gate adds new relevant information, allowing the LSTM to maintain useful long-term context."
        },
        {
            question: "Why are LSTMs called 'Long Short-Term Memory' networks?",
            options: [
                "They have long training times",
                "They can learn both short-term patterns and remember long-term dependencies",
                "They are longer than other networks",
                "They have short memory only"
            ],
            correct: 1,
            explanation: "LSTMs are called 'Long Short-Term Memory' because they can capture both immediate patterns (short-term) and remember important information across long sequences (long-term memory)."
        }
    ]
};

let userAnswers = [];
let submitted = false;

function init() {
    loadQuiz();
    loadProgress();
}

function loadQuiz() {
    const content = document.getElementById('quizContent');
    content.innerHTML = quizData.questions.map((q, index) => `
        <div class="question-card" id="question${index}">
            <div class="question-number">Question ${index + 1} of ${quizData.questions.length}</div>
            <div class="question-text">${q.question}</div>
            <div class="options">
                ${q.options.map((option, optIndex) => `
                    <div class="option" onclick="selectOption(${index}, ${optIndex})" id="q${index}_opt${optIndex}">
                        ${option}
                    </div>
                `).join('')}
            </div>
            <div class="explanation" id="explanation${index}">
                <strong>Explanation:</strong> ${q.explanation}
            </div>
        </div>
    `).join('');
}

function selectOption(questionIndex, optionIndex) {
    if (submitted) return;

    // Clear previous selection
    for (let i = 0; i < quizData.questions[questionIndex].options.length; i++) {
        document.getElementById(`q${questionIndex}_opt${i}`).classList.remove('selected');
    }

    // Mark new selection
    document.getElementById(`q${questionIndex}_opt${optionIndex}`).classList.add('selected');
    userAnswers[questionIndex] = optionIndex;

    updateProgress();
    checkSubmitEnabled();
}

function checkSubmitEnabled() {
    const allAnswered = userAnswers.length === quizData.questions.length &&
                       userAnswers.every(a => a !== undefined);
    document.getElementById('submitBtn').disabled = !allAnswered;
}

function updateProgress() {
    const progress = (userAnswers.filter(a => a !== undefined).length / quizData.questions.length) * 100;
    document.getElementById('progressBar').style.width = progress + '%';
}

function submitQuiz() {
    if (submitted) return;
    submitted = true;

    let correct = 0;

    quizData.questions.forEach((q, index) => {
        const questionCard = document.getElementById(`question${index}`);
        const userAnswer = userAnswers[index];
        const isCorrect = userAnswer === q.correct;

        if (isCorrect) {
            correct++;
            questionCard.classList.add('answered-correct');
        } else {
            questionCard.classList.add('answered-wrong');
        }

        // Show correct/wrong on options
        q.options.forEach((_, optIndex) => {
            const optEl = document.getElementById(`q${index}_opt${optIndex}`);
            optEl.classList.add('disabled');

            if (optIndex === q.correct) {
                optEl.classList.add('correct');
            } else if (optIndex === userAnswer && !isCorrect) {
                optEl.classList.add('wrong');
            }
        });

        // Show explanation
        document.getElementById(`explanation${index}`).classList.add('show');
    });

    const percentage = Math.round((correct / quizData.questions.length) * 100);

    // Save result
    const result = {
        score: correct,
        total: quizData.questions.length,
        percentage: percentage,
        date: new Date().toISOString()
    };
    localStorage.setItem(`quiz_${quizData.id}`, JSON.stringify(result));

    // Show results
    showResults(correct, percentage);
}

function showResults(correct, percentage) {
    const content = document.getElementById('quizContent');
    let message = '';
    if (percentage >= 90) message = 'Excellent! You have mastered LSTM networks!';
    else if (percentage >= 70) message = 'Great job! You understand the key concepts!';
    else if (percentage >= 50) message = 'Good effort! Review the lesson to improve!';
    else message = 'Keep learning! Review the lesson and try again!';

    content.innerHTML = `
        <div class="results-card">
            <h2>Quiz Complete!</h2>
            <div class="score-display">${percentage}%</div>
            <p style="font-size: 1.3em; margin: 20px 0;">${message}</p>
            <div class="results-grid">
                <div class="result-stat">
                    <div class="result-stat-value">${correct}</div>
                    <div class="result-stat-label">Correct</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value">${quizData.questions.length - correct}</div>
                    <div class="result-stat-label">Incorrect</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value">${correct * 10}</div>
                    <div class="result-stat-label">Points Earned</div>
                </div>
            </div>
        </div>
    ` + content.innerHTML;

    document.getElementById('submitBtn').style.display = 'none';
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

function retakeQuiz() {
    if (confirm('Retake the quiz? Your previous score will be replaced.')) {
        userAnswers = [];
        submitted = false;
        document.getElementById('submitBtn').style.display = 'inline-block';
        init();
        updateProgress();
    }
}

function loadProgress() {
    // Could load previous answers here if needed
}

// Initialize
init();
</script>
</body>
</html>
