<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spot the Sketchy Graph - Misleading Graphs Game</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 0; }
.nav-header { background: #2d3748; padding: 15px 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex; justify-content: space-between; align-items: center; }
.nav-header a { color: #90cdf4; text-decoration: none; font-weight: 600; font-size: 1.1em; }
.nav-title { color: #fff; font-size: 1.2em; font-weight: 700; }
.container { max-width: 1400px; margin: 20px auto; background: #fff; border-radius: 15px; padding: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
h1 { text-align: center; color: #2d3748; font-size: 2.5em; margin-bottom: 10px; }
.subtitle { text-align: center; color: #666; margin-bottom: 30px; font-size: 1.1em; }
.game-area { display: grid; grid-template-columns: 350px 1fr; gap: 30px; }
.sidebar { background: #f8f9fa; padding: 20px; border-radius: 10px; height: fit-content; }
button { width: 100%; padding: 12px; margin: 5px 0; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s; }
.btn-primary { background: #4CAF50; color: #fff; }
.btn-primary:hover { background: #45a049; }
.btn-secondary { background: #2196F3; color: #fff; }
.btn-secondary:hover { background: #0b7dda; }
.btn-submit { background: #ff9800; color: #fff; }
.btn-submit:hover { background: #fb8c00; }
.btn-submit:disabled { background: #ccc; cursor: not-allowed; }
canvas { border: 2px solid #ddd; border-radius: 8px; display: block; background: #fff; margin: 0 auto; }
.stats { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; padding: 15px; border-radius: 10px; margin: 15px 0; }
.stat-row { display: flex; justify-content: space-between; margin: 8px 0; }
.score-board { background: #fff9c4; padding: 20px; border-radius: 10px; text-align: center; margin: 20px 0; border: 2px solid #fbc02d; }
.score-board h2 { color: #f57c00; margin-bottom: 10px; }
.score-value { font-size: 2.5em; font-weight: bold; color: #667eea; }
.question-section { background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0; }
.question { font-size: 1.2em; font-weight: 600; color: #2d3748; margin-bottom: 15px; }
.issues-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 15px; }
.issue-checkbox { display: flex; align-items: center; padding: 12px; border: 2px solid #ddd; background: #fff; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
.issue-checkbox:hover { border-color: #667eea; background: #f0f0ff; }
.issue-checkbox.selected { border-color: #667eea; background: #e3f2fd; }
.issue-checkbox.correct { border-color: #4CAF50; background: #e8f5e9; }
.issue-checkbox.incorrect { border-color: #f44336; background: #ffebee; }
.issue-checkbox input { margin-right: 10px; cursor: pointer; }
.issue-checkbox label { cursor: pointer; flex: 1; font-size: 0.95em; }
.feedback { padding: 15px; border-radius: 8px; margin-top: 15px; display: none; }
.feedback.show { display: block; animation: slideIn 0.3s; }
.feedback.correct { background: #e8f5e9; border-left: 4px solid #4CAF50; color: #2e7d32; }
.feedback.incorrect { background: #ffebee; border-left: 4px solid #f44336; color: #c62828; }
.feedback strong { display: block; margin-bottom: 5px; font-size: 1.1em; }
@keyframes slideIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
.progress-indicator { background: #e0e0e0; height: 8px; border-radius: 4px; margin: 15px 0; overflow: hidden; }
.progress-bar { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); transition: width 0.3s; }
.info-box { background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 15px 0; }
.info-box h4 { color: #1976d2; margin-bottom: 8px; }
.graph-title { text-align: center; font-size: 1.3em; font-weight: 600; color: #2d3748; margin-bottom: 10px; }
.comparison-section { margin-top: 20px; padding: 20px; background: #f0f0f0; border-radius: 10px; display: none; }
.comparison-section.show { display: block; }
.comparison-title { font-size: 1.2em; font-weight: 600; color: #2e7d32; margin-bottom: 15px; text-align: center; }
.before-after-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
.graph-card { background: #fff; padding: 15px; border-radius: 8px; border: 2px solid #ddd; }
.graph-card h4 { text-align: center; margin-bottom: 10px; }
.graph-card.misleading h4 { color: #d32f2f; }
.graph-card.honest h4 { color: #2e7d32; }
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">Spot the Sketchy Graph</div>
    <a href="../../index.html">← Back to Home</a>
</nav>
<div class="container">
    <h1>Spot the Sketchy Graph</h1>
    <p class="subtitle">Identify misleading techniques in deceptive graphs - Select ALL issues you can spot!</p>

    <div class="game-area">
        <div class="sidebar">
            <h3>Game Progress</h3>

            <div class="progress-indicator">
                <div class="progress-bar" id="progressBar" style="width: 0%"></div>
            </div>
            <div style="text-align: center; margin-bottom: 15px; color: #666;">
                <span id="progressText">Graph 0 of 10</span>
            </div>

            <button class="btn-primary" onclick="startGame()">Start Game</button>
            <button class="btn-submit" id="submitBtn" onclick="submitAnswer()" disabled>Submit Answer</button>
            <button class="btn-secondary" onclick="nextGraph()">Next Graph</button>

            <div class="stats">
                <div class="stat-row"><span>Graphs Analyzed:</span><span id="analyzed">0</span></div>
                <div class="stat-row"><span>Fully Correct:</span><span id="perfect">0</span></div>
                <div class="stat-row"><span>Accuracy:</span><span id="accuracy">0%</span></div>
                <div class="stat-row"><span>Score:</span><span id="score">0</span></div>
            </div>

            <div class="info-box">
                <h4>Common Tricks to Look For:</h4>
                <p style="font-size: 0.9em; line-height: 1.6;">
                    <strong>Truncated Y-Axis</strong> - Doesn't start at zero<br>
                    <strong>Cherry-Picked Data</strong> - Selective time ranges<br>
                    <strong>Misleading Scale</strong> - Dual axes tricks<br>
                    <strong>3D Distortion</strong> - Fake perspective<br>
                    <strong>Missing Context</strong> - No units or labels<br>
                    <strong>Wrong Chart Type</strong> - Inappropriate visualization
                </p>
            </div>

            <div style="background: #fff3e0; padding: 12px; border-radius: 8px; margin-top: 15px;">
                <p style="font-size: 0.85em; line-height: 1.5; color: #e65100;">
                    <strong>Tip:</strong> Some graphs may have multiple issues! Make sure to select ALL problems
                    you can identify to get full points.
                </p>
            </div>
        </div>

        <div>
            <div class="score-board">
                <h2>Current Score</h2>
                <div class="score-value" id="displayScore">0</div>
                <p style="margin-top: 10px; color: #666; font-size: 0.9em;">Perfect identification = 100 points | Partial = 50 points</p>
            </div>

            <div class="graph-title" id="graphTitle">Click "Start Game" to begin identifying sketchy graphs!</div>
            <canvas id="canvas" width="900" height="450"></canvas>

            <div class="question-section" id="questionSection" style="display: none;">
                <div class="question">What's wrong with this graph? (Select ALL that apply)</div>
                <div class="issues-grid" id="issuesGrid">
                    <!-- Populated by JavaScript -->
                </div>
                <div class="feedback" id="feedback"></div>
            </div>

            <div class="comparison-section" id="comparisonSection">
                <div class="comparison-title">Here's the Corrected Version:</div>
                <div class="before-after-grid">
                    <div class="graph-card misleading">
                        <h4>Misleading Graph</h4>
                        <canvas id="misleadingCanvas" width="400" height="300"></canvas>
                    </div>
                    <div class="graph-card honest">
                        <h4>Honest Graph</h4>
                        <canvas id="honestCanvas" width="400" height="300"></canvas>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 15px; background: #e8f5e9; border-radius: 8px; border-left: 4px solid #4CAF50;">
                    <strong style="color: #2e7d32;">Explanation:</strong>
                    <p id="explanation" style="margin-top: 8px; line-height: 1.6; color: #1b5e20;"></p>
                </div>
            </div>

            <div style="background: #e3f2fd; padding: 20px; border-radius: 10px; margin-top: 20px; border-left: 4px solid #1976d2;">
                <h4 style="color: #0d47a1; margin-bottom: 10px;">Why This Matters</h4>
                <p style="line-height: 1.6;">
                    Misleading graphs are everywhere - in news articles, political campaigns, business presentations, and
                    social media. Learning to spot these manipulations helps you make better decisions, avoid being misled,
                    and become a more critical consumer of information. As future data scientists and AI practitioners,
                    you have an ethical responsibility to present data honestly and transparently.
                </p>
            </div>
        </div>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const allIssues = [
    'Truncated Y-Axis',
    'Cherry-Picked Data Range',
    'Misleading Dual Axes',
    '3D Distortion',
    'Missing Labels/Context',
    'Wrong Chart Type',
    'Inconsistent Scale',
    'Exaggerated Visual Size'
];

const graphs = [
    {
        title: "Monthly Sales 'Skyrocket'",
        issues: ['Truncated Y-Axis', 'Exaggerated Visual Size'],
        draw: (canvas) => drawTruncatedSales(canvas, true),
        drawHonest: (canvas) => drawTruncatedSales(canvas, false),
        explanation: "The y-axis starts at 95 instead of 0, making a 3% increase look like a massive jump. Always check if the y-axis starts at zero to see the true scale of change."
    },
    {
        title: "Stock Performance - 'Rising Trend'",
        issues: ['Cherry-Picked Data Range', 'Missing Labels/Context'],
        draw: (canvas) => drawCherryPickedStock(canvas, true),
        drawHonest: (canvas) => drawCherryPickedStock(canvas, false),
        explanation: "Only showing Q1 data hides the full-year decline. The graph cherry-picks a favorable time period while hiding the bigger picture. Always ask to see the complete dataset."
    },
    {
        title: "Ice Cream Sales Cause Drowning!",
        issues: ['Misleading Dual Axes', 'Wrong Chart Type'],
        draw: (canvas) => drawDualAxisTrick(canvas, true),
        drawHonest: (canvas) => drawDualAxisTrick(canvas, false),
        explanation: "Different scales on the dual axes create a false correlation. When plotted on the same scale, there's no real relationship - this is a classic spurious correlation."
    },
    {
        title: "Market Share Comparison",
        issues: ['3D Distortion', 'Wrong Chart Type', 'Exaggerated Visual Size'],
        draw: (canvas) => draw3DPieDistortion(canvas, true),
        drawHonest: (canvas) => draw3DPieDistortion(canvas, false),
        explanation: "3D perspective distorts the visual proportions. The front slice appears much larger than it actually is. A simple 2D chart shows the true proportions clearly."
    },
    {
        title: "Temperature Increase - Climate Data",
        issues: ['Truncated Y-Axis', 'Cherry-Picked Data Range', 'Missing Labels/Context'],
        draw: (canvas) => drawClimateData(canvas, true),
        drawHonest: (canvas) => drawClimateData(canvas, false),
        explanation: "Truncated axis starting at 58°F makes a 2° change look extreme. Also shows only recent years without historical context. The honest version shows the full scale and longer timeframe."
    },
    {
        title: "Company Revenue Growth",
        issues: ['Inconsistent Scale', 'Exaggerated Visual Size'],
        draw: (canvas) => drawInconsistentScale(canvas, true),
        drawHonest: (canvas) => drawInconsistentScale(canvas, false),
        explanation: "The bar widths and spacing are inconsistent, creating visual distortion. The bars should all be the same width with equal spacing to allow fair comparison."
    },
    {
        title: "Employment Statistics",
        issues: ['Truncated Y-Axis', 'Missing Labels/Context', 'Exaggerated Visual Size'],
        draw: (canvas) => drawEmployment(canvas, true),
        drawHonest: (canvas) => drawEmployment(canvas, false),
        explanation: "Y-axis starts at 90% instead of 0%, making a small 2% change look massive. Missing proper labels and context about what the percentages represent."
    },
    {
        title: "Product Comparison - Size vs Performance",
        issues: ['Exaggerated Visual Size', 'Wrong Chart Type', '3D Distortion'],
        draw: (canvas) => drawAreaDistortion(canvas, true),
        drawHonest: (canvas) => drawAreaDistortion(canvas, false),
        explanation: "Using circles/bubbles to show doubling values actually quadruples the visual area (πr²), exaggerating differences. A bar chart shows the true 2x difference clearly."
    },
    {
        title: "Medication Effectiveness Study",
        issues: ['Cherry-Picked Data Range', 'Truncated Y-Axis', 'Missing Labels/Context'],
        draw: (canvas) => drawMedicationStudy(canvas, true),
        drawHonest: (canvas) => drawMedicationStudy(canvas, false),
        explanation: "Shows only successful age groups and uses truncated axis. The complete data reveals the medication works for only a small subset of patients."
    },
    {
        title: "Crime Rate - 'Dangerous Spike'",
        issues: ['Truncated Y-Axis', 'Cherry-Picked Data Range', 'Exaggerated Visual Size'],
        draw: (canvas) => drawCrimeRate(canvas, true),
        drawHonest: (canvas) => drawCrimeRate(canvas, false),
        explanation: "Truncated y-axis starting at 95 crimes and showing only 3 months makes normal variation look like a crime wave. The full year with proper scale shows stable rates."
    }
];

let currentGraphIndex = 0;
let totalAnalyzed = 0;
let totalPerfect = 0;
let score = 0;
let gameStarted = false;
let selectedIssues = new Set();

function startGame() {
    currentGraphIndex = 0;
    totalAnalyzed = 0;
    totalPerfect = 0;
    score = 0;
    gameStarted = true;
    updateStats();
    loadGraph();
}

function loadGraph() {
    if (currentGraphIndex >= graphs.length) {
        endGame();
        return;
    }

    const graph = graphs[currentGraphIndex];
    selectedIssues.clear();

    document.getElementById('graphTitle').textContent = graph.title;
    document.getElementById('questionSection').style.display = 'block';
    document.getElementById('comparisonSection').classList.remove('show');
    document.getElementById('feedback').className = 'feedback';
    document.getElementById('submitBtn').disabled = false;

    // Draw the misleading graph
    graph.draw(canvas);

    // Create issue checkboxes
    const issuesGrid = document.getElementById('issuesGrid');
    issuesGrid.innerHTML = '';

    allIssues.forEach((issue, index) => {
        const div = document.createElement('div');
        div.className = 'issue-checkbox';
        div.id = `issue-${index}`;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `checkbox-${index}`;
        checkbox.value = issue;
        checkbox.onchange = () => toggleIssue(issue, div);

        const label = document.createElement('label');
        label.htmlFor = `checkbox-${index}`;
        label.textContent = issue;

        div.appendChild(checkbox);
        div.appendChild(label);
        div.onclick = (e) => {
            if (e.target !== checkbox) {
                checkbox.checked = !checkbox.checked;
                toggleIssue(issue, div);
            }
        };

        issuesGrid.appendChild(div);
    });

    updateProgress();
}

function toggleIssue(issue, div) {
    if (selectedIssues.has(issue)) {
        selectedIssues.delete(issue);
        div.classList.remove('selected');
    } else {
        selectedIssues.add(issue);
        div.classList.add('selected');
    }
}

function submitAnswer() {
    const graph = graphs[currentGraphIndex];
    const correctIssues = new Set(graph.issues);

    totalAnalyzed++;

    // Calculate score
    const selectedCorrect = [...selectedIssues].filter(issue => correctIssues.has(issue)).length;
    const selectedIncorrect = selectedIssues.size - selectedCorrect;
    const missedIssues = graph.issues.length - selectedCorrect;

    const isPerfect = selectedIssues.size === correctIssues.size &&
                     [...selectedIssues].every(issue => correctIssues.has(issue));

    // Scoring: 100 for perfect, 50 for partial, 0 for completely wrong
    let pointsEarned = 0;
    if (isPerfect) {
        pointsEarned = 100;
        totalPerfect++;
    } else if (selectedCorrect > 0 && selectedCorrect >= missedIssues) {
        pointsEarned = 50;
    }

    score += pointsEarned;

    // Show feedback
    const feedbackEl = document.getElementById('feedback');
    feedbackEl.className = isPerfect ? 'feedback correct show' : 'feedback incorrect show';

    if (isPerfect) {
        feedbackEl.innerHTML = `
            <strong>Perfect! +${pointsEarned} points</strong>
            You identified all ${correctIssues.size} issue(s) correctly!
        `;
    } else {
        feedbackEl.innerHTML = `
            <strong>${pointsEarned > 0 ? 'Partial Credit' : 'Incorrect'} - +${pointsEarned} points</strong>
            You found ${selectedCorrect} of ${correctIssues.size} issues.
            ${selectedIncorrect > 0 ? `You also selected ${selectedIncorrect} incorrect issue(s).` : ''}
            <br><br><strong>Correct issues:</strong> ${graph.issues.join(', ')}
        `;
    }

    // Color code the checkboxes
    allIssues.forEach((issue, index) => {
        const div = document.getElementById(`issue-${index}`);
        const checkbox = document.getElementById(`checkbox-${index}`);
        checkbox.disabled = true;

        if (correctIssues.has(issue)) {
            div.classList.add('correct');
        } else if (selectedIssues.has(issue)) {
            div.classList.add('incorrect');
        }
    });

    // Show comparison
    showComparison();

    document.getElementById('submitBtn').disabled = true;
    updateStats();

    setTimeout(() => {
        currentGraphIndex++;
        loadGraph();
    }, 8000);
}

function showComparison() {
    const graph = graphs[currentGraphIndex];
    const comparisonSection = document.getElementById('comparisonSection');
    comparisonSection.classList.add('show');

    const misleadingCanvas = document.getElementById('misleadingCanvas');
    const honestCanvas = document.getElementById('honestCanvas');

    graph.draw(misleadingCanvas);
    graph.drawHonest(honestCanvas);

    document.getElementById('explanation').textContent = graph.explanation;
}

function nextGraph() {
    if (!gameStarted) {
        alert('Please start the game first!');
        return;
    }
    if (document.getElementById('submitBtn').disabled === false) {
        alert('Please submit your answer first!');
        return;
    }
    currentGraphIndex++;
    loadGraph();
}

function updateStats() {
    document.getElementById('analyzed').textContent = totalAnalyzed;
    document.getElementById('perfect').textContent = totalPerfect;
    document.getElementById('accuracy').textContent =
        totalAnalyzed > 0 ? Math.round((totalPerfect / totalAnalyzed) * 100) + '%' : '0%';
    document.getElementById('score').textContent = score;
    document.getElementById('displayScore').textContent = score;
}

function updateProgress() {
    const progress = (currentGraphIndex / graphs.length) * 100;
    document.getElementById('progressBar').style.width = progress + '%';
    document.getElementById('progressText').textContent =
        `Graph ${currentGraphIndex + 1} of ${graphs.length}`;
}

function endGame() {
    const accuracy = Math.round((totalPerfect / totalAnalyzed) * 100);
    const maxScore = graphs.length * 100;

    let message = `Game Complete!\n\n`;
    message += `Final Score: ${score} / ${maxScore}\n`;
    message += `Perfect Identifications: ${totalPerfect} / ${totalAnalyzed}\n`;
    message += `Accuracy: ${accuracy}%\n\n`;

    if (accuracy >= 80) {
        message += "Outstanding! You're a graph detective expert!";
    } else if (accuracy >= 60) {
        message += "Great work! You can spot most misleading graphs!";
    } else if (accuracy >= 40) {
        message += "Good progress! Keep practicing to sharpen your skills!";
    } else {
        message += "Keep learning! Review the lessons and try again.";
    }

    alert(message);
    gameStarted = false;
}

// Drawing functions for each graph type
function drawTruncatedSales(canvas, misleading) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const data = [98, 98.5, 99, 99.5, 100, 100.5, 101];
    const labels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul'];

    const offsetX = 100;
    const offsetY = 60;
    const chartWidth = 650;
    const chartHeight = 320;

    const minValue = misleading ? 95 : 0;
    const maxValue = misleading ? 102 : 110;
    const range = maxValue - minValue;

    // Axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY);
    ctx.lineTo(offsetX, offsetY + chartHeight);
    ctx.lineTo(offsetX + chartWidth, offsetY + chartHeight);
    ctx.stroke();

    // Y-axis label
    ctx.fillStyle = '#333';
    ctx.font = 'bold 14px Arial';
    ctx.save();
    ctx.translate(30, offsetY + chartHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Sales ($1000s)', 0, 0);
    ctx.restore();

    // Y-axis ticks
    ctx.font = '12px Arial';
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
        const value = minValue + (range * i / 5);
        const y = offsetY + chartHeight - (i * chartHeight / 5);
        ctx.fillText(value.toFixed(0), offsetX - 10, y + 4);

        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(offsetX, y);
        ctx.lineTo(offsetX + chartWidth, y);
        ctx.stroke();
    }

    // Draw line
    ctx.strokeStyle = misleading ? '#d32f2f' : '#2196F3';
    ctx.lineWidth = 4;
    ctx.beginPath();

    data.forEach((value, i) => {
        const x = offsetX + (i * chartWidth / (data.length - 1));
        const y = offsetY + chartHeight - ((value - minValue) / range * chartHeight);

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });

    ctx.stroke();

    // Points and labels
    ctx.textAlign = 'center';
    data.forEach((value, i) => {
        const x = offsetX + (i * chartWidth / (data.length - 1));
        const y = offsetY + chartHeight - ((value - minValue) / range * chartHeight);

        ctx.fillStyle = misleading ? '#d32f2f' : '#2196F3';
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.fillText(labels[i], x, offsetY + chartHeight + 25);
    });

    // Title
    ctx.font = 'bold 16px Arial';
    ctx.fillText(misleading ? 'SALES SKYROCKETING!' : 'Monthly Sales (Full Scale)', canvas.width / 2, 35);
}

function drawCherryPickedStock(canvas, misleading) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const fullData = [100, 105, 110, 108, 102, 95, 88, 82, 78, 80, 83, 85];
    const labels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    const displayData = misleading ? fullData.slice(0, 3) : fullData;
    const displayLabels = misleading ? labels.slice(0, 3) : labels;

    const offsetX = 100;
    const offsetY = 60;
    const chartWidth = 650;
    const chartHeight = 320;

    // Axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY);
    ctx.lineTo(offsetX, offsetY + chartHeight);
    ctx.lineTo(offsetX + chartWidth, offsetY + chartHeight);
    ctx.stroke();

    // Y-axis label
    ctx.fillStyle = '#333';
    ctx.font = 'bold 14px Arial';
    ctx.save();
    ctx.translate(30, offsetY + chartHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(misleading ? 'Price' : 'Stock Price ($)', 0, 0);
    ctx.restore();

    // Y-axis ticks
    ctx.font = '12px Arial';
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
        const value = i * 25;
        const y = offsetY + chartHeight - (i * chartHeight / 5);
        ctx.fillText(misleading ? '' : '$' + value, offsetX - 10, y + 4);

        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(offsetX, y);
        ctx.lineTo(offsetX + chartWidth, y);
        ctx.stroke();
    }

    // Draw line
    ctx.strokeStyle = misleading ? '#4CAF50' : '#d32f2f';
    ctx.lineWidth = 4;
    ctx.beginPath();

    displayData.forEach((value, i) => {
        const x = offsetX + (i * chartWidth / (displayData.length - 1));
        const y = offsetY + chartHeight - (value / 125 * chartHeight);

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });

    ctx.stroke();

    // Points and labels
    ctx.textAlign = 'center';
    displayData.forEach((value, i) => {
        const x = offsetX + (i * chartWidth / (displayData.length - 1));
        const y = offsetY + chartHeight - (value / 125 * chartHeight);

        ctx.fillStyle = misleading ? '#4CAF50' : '#d32f2f';
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.fillText(displayLabels[i], x, offsetY + chartHeight + 25);
    });

    // Title
    ctx.font = 'bold 16px Arial';
    ctx.fillText(
        misleading ? 'Stock Rising Fast!' : 'Full Year Stock Performance',
        canvas.width / 2, 35
    );
}

function drawDualAxisTrick(canvas, misleading) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const iceCream = [100, 120, 180, 250, 300, 280, 200, 150];
    const drownings = [2, 3, 4, 6, 7, 6, 5, 3];
    const labels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug'];

    const offsetX = 100;
    const offsetY = 60;
    const chartWidth = 600;
    const chartHeight = 320;

    // Axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY);
    ctx.lineTo(offsetX, offsetY + chartHeight);
    ctx.lineTo(offsetX + chartWidth, offsetY + chartHeight);
    if (misleading) {
        ctx.moveTo(offsetX + chartWidth, offsetY);
        ctx.lineTo(offsetX + chartWidth, offsetY + chartHeight);
    }
    ctx.stroke();

    // Labels
    ctx.fillStyle = '#ff9800';
    ctx.font = 'bold 12px Arial';
    ctx.save();
    ctx.translate(25, offsetY + chartHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Ice Cream Sales', 0, 0);
    ctx.restore();

    if (misleading) {
        ctx.fillStyle = '#2196F3';
        ctx.save();
        ctx.translate(canvas.width - 25, offsetY + chartHeight / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Drownings', 0, 0);
        ctx.restore();
    }

    // Draw Ice Cream line
    ctx.strokeStyle = '#ff9800';
    ctx.lineWidth = 3;
    ctx.beginPath();
    iceCream.forEach((value, i) => {
        const x = offsetX + (i * chartWidth / (iceCream.length - 1));
        const y = offsetY + chartHeight - (value / 300 * chartHeight);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Draw Drownings line
    ctx.strokeStyle = '#2196F3';
    ctx.lineWidth = 3;
    ctx.beginPath();
    drownings.forEach((value, i) => {
        const x = offsetX + (i * chartWidth / (drownings.length - 1));
        const y = misleading ?
            offsetY + chartHeight - (value / 7 * chartHeight) :
            offsetY + chartHeight - (value / 300 * chartHeight);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // X-axis labels
    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    labels.forEach((label, i) => {
        const x = offsetX + (i * chartWidth / (labels.length - 1));
        ctx.fillText(label, x, offsetY + chartHeight + 25);
    });

    // Title
    ctx.font = 'bold 16px Arial';
    ctx.fillText(
        misleading ? 'Ice Cream Sales Cause Drowning!' : 'No Real Correlation (Same Scale)',
        canvas.width / 2, 35
    );

    // Legend
    ctx.fillStyle = '#ff9800';
    ctx.fillRect(offsetX, offsetY - 30, 15, 10);
    ctx.fillStyle = '#333';
    ctx.font = '11px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Ice Cream', offsetX + 20, offsetY - 22);

    ctx.fillStyle = '#2196F3';
    ctx.fillRect(offsetX + 120, offsetY - 30, 15, 10);
    ctx.fillStyle = '#333';
    ctx.fillText('Drownings', offsetX + 140, offsetY - 22);
}

function draw3DPieDistortion(canvas, misleading) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const data = [35, 30, 20, 15];
    const labels = ['Product A', 'Product B', 'Product C', 'Product D'];
    const colors = ['#2196F3', '#4CAF50', '#ff9800', '#f44336'];

    if (misleading) {
        // 3D Pie with distortion
        const centerX = 450;
        const centerY = 200;
        const radius = 140;
        const depth = 40;

        // Draw 3D depth
        let startAngle = -0.5;
        data.forEach((value, i) => {
            const angle = (value / 100) * Math.PI * 2;

            ctx.fillStyle = shadeColor(colors[i], -30);
            ctx.beginPath();
            ctx.ellipse(centerX, centerY + depth, radius, radius * 0.5, 0, startAngle, startAngle + angle);
            ctx.lineTo(centerX, centerY + depth);
            ctx.fill();

            startAngle += angle;
        });

        // Draw top with perspective distortion
        startAngle = -0.5;
        data.forEach((value, i) => {
            const angle = (value / 100) * Math.PI * 2;
            const distortion = i === 0 ? 1.4 : 1.0; // Front slice looks bigger

            ctx.fillStyle = colors[i];
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radius * distortion, radius * 0.5, 0, startAngle, startAngle + angle);
            ctx.lineTo(centerX, centerY);
            ctx.fill();

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            startAngle += angle;
        });

        ctx.fillStyle = '#333';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Market Share', centerX, 50);

    } else {
        // Simple bar chart
        const barWidth = 140;
        const maxHeight = 280;
        const offsetX = 100;
        const offsetY = 360;

        // Y-axis
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(offsetX - 10, offsetY - maxHeight - 10);
        ctx.lineTo(offsetX - 10, offsetY);
        ctx.lineTo(offsetX + 650, offsetY);
        ctx.stroke();

        ctx.fillStyle = '#333';
        ctx.font = 'bold 12px Arial';
        ctx.save();
        ctx.translate(30, offsetY - 140);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Market Share (%)', 0, 0);
        ctx.restore();

        data.forEach((value, i) => {
            const x = offsetX + i * 160;
            const height = (value / 40) * maxHeight;
            const y = offsetY - height;

            ctx.fillStyle = colors[i];
            ctx.fillRect(x, y, barWidth, height);

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, barWidth, height);

            // Value
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(value + '%', x + barWidth / 2, y - 10);

            // Label
            ctx.font = '12px Arial';
            ctx.fillText(labels[i], x + barWidth / 2, offsetY + 25);
        });

        ctx.font = 'bold 16px Arial';
        ctx.fillText('Market Share - Clear Comparison', canvas.width / 2, 35);
    }
}

function drawClimateData(canvas, misleading) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const fullData = misleading ?
        [58.2, 58.5, 58.8, 59.2, 59.8, 60.2] :
        [57.0, 57.2, 57.5, 57.8, 58.0, 58.2, 58.5, 58.8, 59.2, 59.8, 60.2];

    const labels = misleading ?
        ['2018', '2019', '2020', '2021', '2022', '2023'] :
        ['2013', '2014', '2015', '2016', '2017', '2018', '2019', '2020', '2021', '2022', '2023'];

    const offsetX = 100;
    const offsetY = 60;
    const chartWidth = 650;
    const chartHeight = 320;

    const minValue = misleading ? 58 : 0;
    const maxValue = misleading ? 61 : 70;
    const range = maxValue - minValue;

    // Axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY);
    ctx.lineTo(offsetX, offsetY + chartHeight);
    ctx.lineTo(offsetX + chartWidth, offsetY + chartHeight);
    ctx.stroke();

    // Y-axis label
    ctx.fillStyle = '#333';
    ctx.font = 'bold 14px Arial';
    ctx.save();
    ctx.translate(25, offsetY + chartHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(misleading ? 'Temp' : 'Temperature (°F)', 0, 0);
    ctx.restore();

    // Y-axis ticks
    ctx.font = '12px Arial';
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
        const value = minValue + (range * i / 5);
        const y = offsetY + chartHeight - (i * chartHeight / 5);
        ctx.fillText(value.toFixed(0), offsetX - 10, y + 4);

        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(offsetX, y);
        ctx.lineTo(offsetX + chartWidth, y);
        ctx.stroke();
    }

    // Draw line
    ctx.strokeStyle = '#d32f2f';
    ctx.lineWidth = 4;
    ctx.beginPath();

    fullData.forEach((value, i) => {
        const x = offsetX + (i * chartWidth / (fullData.length - 1));
        const y = offsetY + chartHeight - ((value - minValue) / range * chartHeight);

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });

    ctx.stroke();

    // Points and labels
    ctx.textAlign = 'center';
    fullData.forEach((value, i) => {
        const x = offsetX + (i * chartWidth / (fullData.length - 1));
        const y = offsetY + chartHeight - ((value - minValue) / range * chartHeight);

        ctx.fillStyle = '#d32f2f';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();

        if (i % (misleading ? 1 : 2) === 0) {
            ctx.fillStyle = '#333';
            ctx.font = '11px Arial';
            ctx.fillText(labels[i], x, offsetY + chartHeight + 25);
        }
    });

    // Title
    ctx.font = 'bold 16px Arial';
    ctx.fillText(
        misleading ? 'CLIMATE CRISIS!' : 'Global Temperature Trend (Full Context)',
        canvas.width / 2, 35
    );
}

function drawInconsistentScale(canvas, misleading) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const data = [100, 150, 200, 250];
    const labels = ['Q1', 'Q2', 'Q3', 'Q4'];
    const colors = ['#2196F3', '#4CAF50', '#ff9800', '#f44336'];

    const offsetX = 100;
    const offsetY = 360;
    const maxHeight = 280;

    // Axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(offsetX - 10, offsetY - maxHeight - 10);
    ctx.lineTo(offsetX - 10, offsetY);
    ctx.lineTo(offsetX + 700, offsetY);
    ctx.stroke();

    ctx.fillStyle = '#333';
    ctx.font = 'bold 14px Arial';
    ctx.save();
    ctx.translate(30, offsetY - 140);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Revenue ($1M)', 0, 0);
    ctx.restore();

    if (misleading) {
        // Inconsistent widths and spacing
        const widths = [80, 120, 100, 140];
        const spacings = [0, 100, 180, 300];

        data.forEach((value, i) => {
            const x = offsetX + spacings[i];
            const height = (value / 250) * maxHeight;
            const y = offsetY - height;

            ctx.fillStyle = colors[i];
            ctx.fillRect(x, y, widths[i], height);

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, widths[i], height);

            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('$' + value + 'M', x + widths[i] / 2, y - 10);

            ctx.font = '12px Arial';
            ctx.fillText(labels[i], x + widths[i] / 2, offsetY + 25);
        });
    } else {
        // Consistent widths and spacing
        const barWidth = 120;
        const spacing = 150;

        data.forEach((value, i) => {
            const x = offsetX + i * spacing;
            const height = (value / 250) * maxHeight;
            const y = offsetY - height;

            ctx.fillStyle = colors[i];
            ctx.fillRect(x, y, barWidth, height);

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, barWidth, height);

            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('$' + value + 'M', x + barWidth / 2, y - 10);

            ctx.font = '12px Arial';
            ctx.fillText(labels[i], x + barWidth / 2, offsetY + 25);
        });
    }

    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(
        misleading ? 'Quarterly Revenue Growth!' : 'Quarterly Revenue (Consistent Scale)',
        canvas.width / 2, 35
    );
}

function drawEmployment(canvas, misleading) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const data = [92, 92.5, 93, 93.5, 94];
    const labels = ['2019', '2020', '2021', '2022', '2023'];

    const offsetX = 120;
    const offsetY = 60;
    const chartWidth = 620;
    const chartHeight = 320;

    const minValue = misleading ? 90 : 0;
    const maxValue = misleading ? 95 : 100;
    const range = maxValue - minValue;

    // Axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY);
    ctx.lineTo(offsetX, offsetY + chartHeight);
    ctx.lineTo(offsetX + chartWidth, offsetY + chartHeight);
    ctx.stroke();

    // Y-axis label
    ctx.fillStyle = '#333';
    ctx.font = 'bold 14px Arial';
    ctx.save();
    ctx.translate(30, offsetY + chartHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(misleading ? 'Rate' : 'Employment Rate (%)', 0, 0);
    ctx.restore();

    // Y-axis ticks
    ctx.font = '12px Arial';
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
        const value = minValue + (range * i / 5);
        const y = offsetY + chartHeight - (i * chartHeight / 5);
        ctx.fillText(value.toFixed(0) + (misleading ? '' : '%'), offsetX - 10, y + 4);

        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(offsetX, y);
        ctx.lineTo(offsetX + chartWidth, y);
        ctx.stroke();
    }

    // Bar chart
    const barWidth = 100;
    data.forEach((value, i) => {
        const x = offsetX + 20 + i * (chartWidth / data.length);
        const height = ((value - minValue) / range) * chartHeight;
        const y = offsetY + chartHeight - height;

        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(x, y, barWidth, height);

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, barWidth, height);

        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(labels[i], x + barWidth / 2, offsetY + chartHeight + 25);

        if (!misleading) {
            ctx.font = 'bold 12px Arial';
            ctx.fillText(value + '%', x + barWidth / 2, y - 8);
        }
    });

    // Title
    ctx.font = 'bold 16px Arial';
    ctx.fillText(
        misleading ? 'MASSIVE Employment Gains!' : 'Employment Rate (Full Scale)',
        canvas.width / 2, 35
    );
}

function drawAreaDistortion(canvas, misleading) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const data = [100, 200]; // 2x increase
    const labels = ['Product A', 'Product B'];

    if (misleading) {
        // Using circles - area grows quadratically
        const baseRadius = 80;

        [0, 1].forEach(i => {
            const x = 250 + i * 350;
            const y = 220;
            const radius = baseRadius * Math.sqrt(data[i] / 100); // Correct proportional area
            const displayRadius = baseRadius * (data[i] / 100); // Wrong - doubles radius instead

            // Draw shadow for 3D effect
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.arc(x + 10, y + 10, displayRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = i === 0 ? '#2196F3' : '#4CAF50';
            ctx.beginPath();
            ctx.arc(x, y, displayRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(data[i], x, y + 8);

            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(labels[i], x, y + displayRadius + 30);
        });

        ctx.fillStyle = '#333';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Product Performance Comparison', canvas.width / 2, 40);

    } else {
        // Simple bar chart
        const barWidth = 150;
        const maxHeight = 300;
        const offsetX = 200;
        const offsetY = 380;

        // Axes
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(offsetX - 10, offsetY - maxHeight - 10);
        ctx.lineTo(offsetX - 10, offsetY);
        ctx.lineTo(offsetX + 500, offsetY);
        ctx.stroke();

        ctx.fillStyle = '#333';
        ctx.font = 'bold 14px Arial';
        ctx.save();
        ctx.translate(30, offsetY - 150);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Performance Score', 0, 0);
        ctx.restore();

        data.forEach((value, i) => {
            const x = offsetX + i * 250;
            const height = (value / 200) * maxHeight;
            const y = offsetY - height;

            ctx.fillStyle = i === 0 ? '#2196F3' : '#4CAF50';
            ctx.fillRect(x, y, barWidth, height);

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, barWidth, height);

            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(value, x + barWidth / 2, y - 10);

            ctx.font = '14px Arial';
            ctx.fillText(labels[i], x + barWidth / 2, offsetY + 25);
        });

        ctx.font = 'bold 16px Arial';
        ctx.fillText('Product Performance (Accurate 2x Difference)', canvas.width / 2, 35);
    }
}

function drawMedicationStudy(canvas, misleading) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const fullData = misleading ?
        { ages: ['25-30', '30-35', '35-40'], rates: [75, 80, 85] } :
        { ages: ['18-25', '25-30', '30-35', '35-40', '40-50', '50-60', '60+'],
          rates: [45, 75, 80, 85, 70, 55, 40] };

    const offsetX = 100;
    const offsetY = 60;
    const chartWidth = 650;
    const chartHeight = 320;

    const minValue = misleading ? 70 : 0;
    const maxValue = misleading ? 90 : 100;
    const range = maxValue - minValue;

    // Axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY);
    ctx.lineTo(offsetX, offsetY + chartHeight);
    ctx.lineTo(offsetX + chartWidth, offsetY + chartHeight);
    ctx.stroke();

    // Y-axis label
    ctx.fillStyle = '#333';
    ctx.font = 'bold 14px Arial';
    ctx.save();
    ctx.translate(25, offsetY + chartHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(misleading ? 'Success' : 'Success Rate (%)', 0, 0);
    ctx.restore();

    // Y-axis ticks
    ctx.font = '12px Arial';
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
        const value = minValue + (range * i / 5);
        const y = offsetY + chartHeight - (i * chartHeight / 5);
        ctx.fillText(value.toFixed(0), offsetX - 10, y + 4);

        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(offsetX, y);
        ctx.lineTo(offsetX + chartWidth, y);
        ctx.stroke();
    }

    // Draw bars
    const barWidth = chartWidth / fullData.ages.length - 20;
    fullData.rates.forEach((value, i) => {
        const x = offsetX + 10 + i * (chartWidth / fullData.ages.length);
        const height = ((value - minValue) / range) * chartHeight;
        const y = offsetY + chartHeight - height;

        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(x, y, barWidth, height);

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, barWidth, height);

        ctx.fillStyle = '#333';
        ctx.font = '11px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(fullData.ages[i], x + barWidth / 2, offsetY + chartHeight + 25);

        if (!misleading) {
            ctx.font = 'bold 11px Arial';
            ctx.fillText(value + '%', x + barWidth / 2, y - 8);
        }
    });

    // Title
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(
        misleading ? 'Medication Highly Effective!' : 'Medication Effectiveness (All Ages)',
        canvas.width / 2, 35
    );
}

function drawCrimeRate(canvas, misleading) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const fullData = misleading ?
        [98, 99, 100] :
        [98, 96, 98, 99, 100, 98, 97, 99, 98, 97, 99, 98];

    const labels = misleading ?
        ['Jan', 'Feb', 'Mar'] :
        ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    const offsetX = 100;
    const offsetY = 60;
    const chartWidth = 650;
    const chartHeight = 320;

    const minValue = misleading ? 95 : 0;
    const maxValue = misleading ? 101 : 120;
    const range = maxValue - minValue;

    // Axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY);
    ctx.lineTo(offsetX, offsetY + chartHeight);
    ctx.lineTo(offsetX + chartWidth, offsetY + chartHeight);
    ctx.stroke();

    // Y-axis label
    ctx.fillStyle = '#333';
    ctx.font = 'bold 14px Arial';
    ctx.save();
    ctx.translate(25, offsetY + chartHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(misleading ? 'Crimes' : 'Monthly Crimes', 0, 0);
    ctx.restore();

    // Y-axis ticks
    ctx.font = '12px Arial';
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
        const value = minValue + (range * i / 5);
        const y = offsetY + chartHeight - (i * chartHeight / 5);
        ctx.fillText(value.toFixed(0), offsetX - 10, y + 4);

        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(offsetX, y);
        ctx.lineTo(offsetX + chartWidth, y);
        ctx.stroke();
    }

    // Draw line
    ctx.strokeStyle = '#d32f2f';
    ctx.lineWidth = 4;
    ctx.beginPath();

    fullData.forEach((value, i) => {
        const x = offsetX + (i * chartWidth / (fullData.length - 1));
        const y = offsetY + chartHeight - ((value - minValue) / range * chartHeight);

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });

    ctx.stroke();

    // Points and labels
    ctx.textAlign = 'center';
    fullData.forEach((value, i) => {
        const x = offsetX + (i * chartWidth / (fullData.length - 1));
        const y = offsetY + chartHeight - ((value - minValue) / range * chartHeight);

        ctx.fillStyle = '#d32f2f';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#333';
        ctx.font = '11px Arial';
        if (misleading || i % 2 === 0) {
            ctx.fillText(labels[i], x, offsetY + chartHeight + 25);
        }
    });

    // Title
    ctx.font = 'bold 16px Arial';
    ctx.fillText(
        misleading ? 'CRIME WAVE HITS CITY!' : 'Stable Crime Rate (Full Year)',
        canvas.width / 2, 35
    );
}

function shadeColor(color, percent) {
    const num = parseInt(color.replace('#', ''), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
        (B < 255 ? B < 1 ? 0 : B : 255))
        .toString(16).slice(1);
}

// Initialize
ctx.fillStyle = '#999';
ctx.font = 'bold 24px Arial';
ctx.textAlign = 'center';
ctx.fillText('Click "Start Game" to begin spotting sketchy graphs!', canvas.width / 2, canvas.height / 2);
</script>
</body>
</html>
