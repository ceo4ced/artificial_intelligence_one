<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Network Architect - Feedforward NN Game</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 0; }
.nav-header { background: #2d3748; padding: 15px 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex; justify-content: space-between; align-items: center; }
.nav-header a { color: #90cdf4; text-decoration: none; font-weight: 600; font-size: 1.1em; }
.nav-title { color: #fff; font-size: 1.2em; font-weight: 700; }
.container { max-width: 1400px; margin: 20px auto; background: #fff; border-radius: 15px; padding: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
h1 { text-align: center; color: #2d3748; font-size: 2.5em; margin-bottom: 10px; }
.subtitle { text-align: center; color: #666; margin-bottom: 30px; font-size: 1.1em; }
.game-area { display: grid; grid-template-columns: 350px 1fr; gap: 30px; }
.sidebar { background: #f8f9fa; padding: 20px; border-radius: 10px; height: fit-content; }
button { width: 100%; padding: 12px; margin: 5px 0; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s; }
.btn-primary { background: #4CAF50; color: #fff; }
.btn-primary:hover { background: #45a049; }
.btn-secondary { background: #2196F3; color: #fff; }
.btn-secondary:hover { background: #0b7dda; }
.btn-danger { background: #f44336; color: #fff; }
.btn-danger:hover { background: #da190b; }
canvas { border: 2px solid #ddd; border-radius: 8px; display: block; background: #fafafa; margin: 0 auto; }
.stats { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; padding: 15px; border-radius: 10px; margin-top: 15px; }
.stat-row { display: flex; justify-content: space-between; margin: 8px 0; }
.challenge { background: #fff9c4; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #fbc02d; }
.challenge h4 { color: #f57c00; margin-bottom: 8px; }
.info { background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 15px 0; }
.info h4 { color: #1976d2; margin-bottom: 8px; }
.layer-control { background: white; padding: 15px; border-radius: 8px; margin: 10px 0; border: 2px solid #ddd; }
.layer-control label { display: block; margin-bottom: 8px; font-weight: 600; color: #2d3748; }
.layer-control input { width: 100%; padding: 8px; }
.score { text-align: center; font-size: 2em; font-weight: bold; color: #4CAF50; margin: 15px 0; }
.dataset-selector { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin: 15px 0; }
.dataset-btn { padding: 10px; border: 2px solid #667eea; background: #fff; color: #667eea; border-radius: 8px; cursor: pointer; font-weight: 600; }
.dataset-btn.active { background: #667eea; color: #fff; }
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">üèóÔ∏è Network Architect Game</div>
    <a href="../../index.html">‚Üê Back to Home</a>
</nav>
<div class="container">
    <h1>üèóÔ∏è Network Architect</h1>
    <p class="subtitle">Design your own Feedforward Neural Network and achieve the target accuracy!</p>

    <div class="game-area">
        <div class="sidebar">
            <h3>üéÆ Build Your Network</h3>

            <div class="challenge">
                <h4>üéØ Current Challenge:</h4>
                <p id="challengeText" style="font-size: 0.9em;">Select a dataset to begin!</p>
            </div>

            <h4 style="margin: 15px 0;">üìä Select Dataset:</h4>
            <div class="dataset-selector">
                <button class="dataset-btn active" onclick="selectDataset('xor')">XOR Problem</button>
                <button class="dataset-btn" onclick="selectDataset('circle')">Circle</button>
                <button class="dataset-btn" onclick="selectDataset('spiral')">Spiral</button>
                <button class="dataset-btn" onclick="selectDataset('blobs')">Blobs</button>
            </div>

            <div class="layer-control">
                <label>Hidden Layer 1 Neurons:</label>
                <input type="number" id="layer1" min="1" max="20" value="4" onchange="updateArchitecture()">
            </div>

            <div class="layer-control">
                <label>Hidden Layer 2 Neurons:</label>
                <input type="number" id="layer2" min="0" max="20" value="4" onchange="updateArchitecture()">
                <small style="color: #666;">Set to 0 to remove this layer</small>
            </div>

            <button class="btn-primary" onclick="trainNetwork()">üöÄ Train Network</button>
            <button class="btn-secondary" onclick="testNetwork()">‚úÖ Test Network</button>
            <button class="btn-danger" onclick="reset()">üîÑ Reset</button>

            <div class="stats">
                <div class="stat-row"><span>Training Epochs:</span><span id="epochs">0</span></div>
                <div class="stat-row"><span>Training Accuracy:</span><span id="trainAcc">0%</span></div>
                <div class="stat-row"><span>Test Accuracy:</span><span id="testAcc">0%</span></div>
                <div class="stat-row"><span>Total Neurons:</span><span id="totalNeurons">0</span></div>
            </div>

            <div class="score">
                <div style="font-size: 0.6em; color: #666;">Score</div>
                <div id="score">0</div>
            </div>

            <div class="info">
                <h4>üí° Tips:</h4>
                <p style="font-size: 0.9em; line-height: 1.6;">
                    ‚Ä¢ Start with one hidden layer<br>
                    ‚Ä¢ Add neurons if accuracy is low<br>
                    ‚Ä¢ Add layers for complex patterns<br>
                    ‚Ä¢ More isn't always better!<br>
                    ‚Ä¢ XOR needs at least 2 hidden neurons
                </p>
            </div>
        </div>

        <div>
            <canvas id="canvas" width="800" height="600"></canvas>
            <div style="text-align: center; margin-top: 20px;">
                <p style="color: #666; font-size: 0.9em;">
                    üîµ Blue = Class 0 | üî¥ Red = Class 1 | Gray regions show decision boundaries
                </p>
            </div>
        </div>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let currentDataset = 'xor';
let architecture = [2, 4, 4, 2];
let trainingData = [];
let testData = [];
let trained = false;
let epochs = 0;
let score = 0;

const challenges = {
    xor: { target: 95, description: 'Achieve 95% accuracy on XOR (non-linear problem)' },
    circle: { target: 90, description: 'Achieve 90% accuracy on Circle dataset' },
    spiral: { target: 85, description: 'Achieve 85% accuracy on Spiral (hardest!)' },
    blobs: { target: 95, description: 'Achieve 95% accuracy on Blobs (easiest)' }
};

function selectDataset(dataset) {
    currentDataset = dataset;
    document.querySelectorAll('.dataset-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');

    document.getElementById('challengeText').textContent = challenges[dataset].description;
    generateData();
    trained = false;
    epochs = 0;
    drawCanvas();
}

function generateData() {
    trainingData = [];
    testData = [];

    for (let i = 0; i < 200; i++) {
        const point = generatePoint();
        if (i < 150) trainingData.push(point);
        else testData.push(point);
    }
}

function generatePoint() {
    const x = Math.random() * 2 - 1;
    const y = Math.random() * 2 - 1;
    let label;

    switch(currentDataset) {
        case 'xor':
            label = (x > 0) !== (y > 0) ? 1 : 0;
            break;
        case 'circle':
            const dist = Math.sqrt(x*x + y*y);
            label = dist < 0.6 ? 0 : 1;
            break;
        case 'spiral':
            const angle = Math.atan2(y, x) + Math.PI;
            const radius = Math.sqrt(x*x + y*y);
            label = (angle + radius * 3) % (Math.PI * 2) < Math.PI ? 0 : 1;
            break;
        case 'blobs':
            label = (x > 0 && y > 0) || (x < 0 && y < 0) ? 1 : 0;
            break;
    }

    return { x, y, label };
}

function updateArchitecture() {
    const layer1 = parseInt(document.getElementById('layer1').value) || 2;
    const layer2 = parseInt(document.getElementById('layer2').value) || 0;

    architecture = [2, layer1];
    if (layer2 > 0) architecture.push(layer2);
    architecture.push(2);

    const total = architecture.reduce((a, b) => a + b, 0);
    document.getElementById('totalNeurons').textContent = total;

    trained = false;
    drawCanvas();
}

function trainNetwork() {
    // Simulate training
    epochs = Math.floor(Math.random() * 50) + 50;

    // Calculate accuracy based on architecture quality
    const totalHidden = architecture.slice(1, -1).reduce((a, b) => a + b, 0);
    let baseAccuracy;

    switch(currentDataset) {
        case 'xor':
            baseAccuracy = totalHidden >= 2 ? 90 + Math.random() * 10 : 50 + Math.random() * 30;
            break;
        case 'circle':
            baseAccuracy = totalHidden >= 3 ? 85 + Math.random() * 10 : 60 + Math.random() * 25;
            break;
        case 'spiral':
            baseAccuracy = totalHidden >= 8 ? 80 + Math.random() * 10 : 50 + Math.random() * 30;
            break;
        case 'blobs':
            baseAccuracy = 90 + Math.random() * 10;
            break;
    }

    const accuracy = Math.min(99, baseAccuracy);

    document.getElementById('epochs').textContent = epochs;
    document.getElementById('trainAcc').textContent = accuracy.toFixed(1) + '%';

    trained = true;
    drawDecisionBoundary();

    alert(`Training complete! Achieved ${accuracy.toFixed(1)}% accuracy after ${epochs} epochs.`);
}

function testNetwork() {
    if (!trained) {
        alert('Please train the network first!');
        return;
    }

    const trainAcc = parseFloat(document.getElementById('trainAcc').textContent);
    const testAcc = trainAcc - Math.random() * 5; // Test accuracy slightly lower

    document.getElementById('testAcc').textContent = testAcc.toFixed(1) + '%';

    const target = challenges[currentDataset].target;
    if (testAcc >= target) {
        const bonus = Math.floor((testAcc - target) * 10);
        const neuronPenalty = architecture.reduce((a, b) => a + b, 0);
        score += Math.max(100 - neuronPenalty + bonus, 0);
        document.getElementById('score').textContent = score;
        alert(`üéâ Challenge Complete! Test accuracy: ${testAcc.toFixed(1)}%\n+${Math.max(100 - neuronPenalty + bonus, 0)} points!`);
    } else {
        alert(`Almost there! Need ${target}% but got ${testAcc.toFixed(1)}%.\nTry adjusting your architecture!`);
    }
}

function drawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw grid
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
        const x = i * canvas.width / 10;
        const y = i * canvas.height / 10;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }

    // Draw training data
    trainingData.forEach(point => {
        const x = (point.x + 1) * canvas.width / 2;
        const y = (point.y + 1) * canvas.height / 2;

        ctx.fillStyle = point.label === 0 ? 'rgba(33, 150, 243, 0.7)' : 'rgba(244, 67, 54, 0.7)';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
    });
}

function drawDecisionBoundary() {
    const imageData = ctx.createImageData(canvas.width, canvas.height);

    for (let x = 0; x < canvas.width; x += 2) {
        for (let y = 0; y < canvas.height; y += 2) {
            const normX = (x / canvas.width) * 2 - 1;
            const normY = (y / canvas.height) * 2 - 1;

            let prediction = predictClass(normX, normY);

            const color = prediction === 0 ? [33, 150, 243, 30] : [244, 67, 54, 30];

            for (let dx = 0; dx < 2; dx++) {
                for (let dy = 0; dy < 2; dy++) {
                    const px = x + dx;
                    const py = y + dy;
                    const index = (py * canvas.width + px) * 4;
                    imageData.data[index] = color[0];
                    imageData.data[index + 1] = color[1];
                    imageData.data[index + 2] = color[2];
                    imageData.data[index + 3] = color[3];
                }
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);
    drawCanvas(); // Redraw points on top
}

function predictClass(x, y) {
    // Simple heuristic prediction based on dataset
    switch(currentDataset) {
        case 'xor':
            return (x > 0) !== (y > 0) ? 1 : 0;
        case 'circle':
            return Math.sqrt(x*x + y*y) < 0.6 ? 0 : 1;
        case 'spiral':
            const angle = Math.atan2(y, x) + Math.PI;
            const radius = Math.sqrt(x*x + y*y);
            return (angle + radius * 3) % (Math.PI * 2) < Math.PI ? 0 : 1;
        case 'blobs':
            return (x > 0 && y > 0) || (x < 0 && y < 0) ? 1 : 0;
    }
}

function reset() {
    trained = false;
    epochs = 0;
    document.getElementById('epochs').textContent = '0';
    document.getElementById('trainAcc').textContent = '0%';
    document.getElementById('testAcc').textContent = '0%';
    generateData();
    drawCanvas();
}

// Initialize
updateArchitecture();
generateData();
drawCanvas();
</script>
</body>
</html>
