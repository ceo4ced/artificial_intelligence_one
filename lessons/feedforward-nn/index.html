<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Feedforward Neural Networks - Interactive Lesson</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 0; }
.nav-header { background: #2d3748; padding: 15px 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex; justify-content: space-between; align-items: center; }
.nav-header a { color: #90cdf4; text-decoration: none; font-weight: 600; font-size: 1.1em; }
.nav-title { color: #fff; font-size: 1.2em; font-weight: 700; }
.container { max-width: 1400px; margin: 20px auto; background: #fff; border-radius: 15px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
h1 { text-align: center; color: #2d3748; font-size: 2.5em; margin-bottom: 20px; }
.intro { background: #e3f2fd; padding: 25px; border-radius: 10px; margin-bottom: 30px; line-height: 1.8; }
.intro h2 { color: #1976d2; margin-bottom: 15px; }
.content-section { margin: 30px 0; }
.content-section h3 { color: #2d3748; margin-bottom: 15px; font-size: 1.6em; }
.content-section p { line-height: 1.8; color: #4a5568; margin-bottom: 15px; }
.visual-demo { background: #f8f9fa; padding: 30px; border-radius: 10px; margin: 20px 0; text-align: center; }
canvas { border: 2px solid #ddd; border-radius: 8px; background: #fff; margin: 20px auto; display: block; }
.info-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin: 20px 0; }
.info-card { background: #f0f4f8; padding: 20px; border-radius: 10px; border-left: 4px solid #667eea; }
.info-card h4 { color: #667eea; margin-bottom: 10px; }
.info-card ul { margin-left: 20px; line-height: 1.8; color: #4a5568; }
.highlight { background: #fff9c4; padding: 20px; border-radius: 10px; border-left: 4px solid #fbc02d; margin: 20px 0; }
.highlight h4 { color: #f57c00; margin-bottom: 10px; }
.example-box { background: #e8f5e9; padding: 20px; border-radius: 10px; margin: 20px 0; border-left: 4px solid #4CAF50; }
.example-box h4 { color: #2e7d32; margin-bottom: 10px; }
.controls { text-align: center; margin: 20px 0; }
button { padding: 15px 30px; margin: 10px; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1.1em; background: #667eea; color: white; transition: all 0.3s; }
button:hover { background: #5568d3; transform: translateY(-2px); }
.layer { padding: 10px; margin: 10px 0; background: white; border-radius: 5px; border: 1px solid #ddd; }
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">üß† Feedforward Neural Networks</div>
    <a href="../../index.html">‚Üê Back to Home</a>
</nav>
<div class="container">
    <h1>üß† Feedforward Neural Networks (FNN)</h1>

    <div class="intro">
        <h2>What is a Feedforward Neural Network?</h2>
        <p>
            A Feedforward Neural Network (FNN) is the simplest type of artificial neural network.
            Information flows in one direction‚Äîfrom input to output‚Äîwithout any loops or cycles.
            Think of it as a one-way street where data enters, gets processed through hidden layers,
            and produces a result.
        </p>
    </div>

    <div class="content-section">
        <h3>üìö Key Concepts</h3>
        <div class="info-grid">
            <div class="info-card">
                <h4>Architecture</h4>
                <ul>
                    <li><strong>Input Layer:</strong> Receives raw data</li>
                    <li><strong>Hidden Layers:</strong> Process and transform data</li>
                    <li><strong>Output Layer:</strong> Produces final predictions</li>
                    <li><strong>Weights:</strong> Adjust connection strengths</li>
                </ul>
            </div>

            <div class="info-card">
                <h4>How It Works</h4>
                <ul>
                    <li>Data flows forward through layers</li>
                    <li>Each neuron applies a weighted sum</li>
                    <li>Activation functions add non-linearity</li>
                    <li>Backpropagation adjusts weights</li>
                </ul>
            </div>

            <div class="info-card">
                <h4>Common Activation Functions</h4>
                <ul>
                    <li><strong>ReLU:</strong> max(0, x) - Most popular</li>
                    <li><strong>Sigmoid:</strong> 1/(1+e^-x) - Binary classification</li>
                    <li><strong>Tanh:</strong> (e^x-e^-x)/(e^x+e^-x)</li>
                    <li><strong>Softmax:</strong> Multi-class classification</li>
                </ul>
            </div>

            <div class="info-card">
                <h4>Applications</h4>
                <ul>
                    <li>Image classification</li>
                    <li>Speech recognition</li>
                    <li>Medical diagnosis</li>
                    <li>Financial prediction</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="visual-demo">
        <h3>üé® Interactive Visualization</h3>
        <p>Watch how signals propagate through a feedforward network</p>
        <canvas id="networkCanvas" width="800" height="400"></canvas>
        <div class="controls">
            <button onclick="animate()">‚ñ∂Ô∏è Animate Forward Pass</button>
            <button onclick="reset()">üîÑ Reset</button>
        </div>
    </div>

    <div class="highlight">
        <h4>üîë Key Insight</h4>
        <p>
            The "feedforward" name comes from how information flows: it always moves forward from
            input to output. Unlike recurrent networks, there are no feedback loops or memory of
            past inputs. Each prediction is independent and based solely on the current input.
        </p>
    </div>

    <div class="example-box">
        <h4>üåü Real-World Example: Image Recognition</h4>
        <p>
            When you upload a photo to identify a dog breed:<br><br>
            <strong>Input Layer:</strong> Pixel values (784 pixels = 28√ó28 image)<br>
            <strong>Hidden Layer 1:</strong> 128 neurons detect edges and simple shapes<br>
            <strong>Hidden Layer 2:</strong> 64 neurons recognize patterns like ears, eyes<br>
            <strong>Output Layer:</strong> 10 neurons, one per breed (highest value wins)
        </p>
    </div>

    <div class="content-section">
        <h3>‚ö° Training Process</h3>
        <p>
            <strong>1. Forward Pass:</strong> Input data flows through the network to generate predictions.<br>
            <strong>2. Loss Calculation:</strong> Compare predictions to actual values using a loss function.<br>
            <strong>3. Backward Pass (Backpropagation):</strong> Calculate gradients to determine how to adjust weights.<br>
            <strong>4. Weight Update:</strong> Use gradient descent to minimize loss.<br>
            <strong>5. Repeat:</strong> Iterate thousands of times until the network learns the patterns.
        </p>
    </div>

    <div class="info-grid" style="margin-top: 30px;">
        <div class="example-box">
            <h4>‚úÖ Advantages</h4>
            <ul>
                <li>Simple architecture, easy to implement</li>
                <li>Works well for many tasks</li>
                <li>Fast to train on small datasets</li>
                <li>Foundation for more complex networks</li>
            </ul>
        </div>

        <div class="highlight" style="background: #ffebee;">
            <h4>‚ö†Ô∏è Limitations</h4>
            <ul>
                <li>No memory of previous inputs</li>
                <li>Struggles with sequential data</li>
                <li>Can't handle variable-length inputs</li>
                <li>May require many layers for complex tasks</li>
            </ul>
        </div>
    </div>

    <div style="text-align: center; margin-top: 40px;">
        <a href="../../games/feedforward-nn/index.html" style="display: inline-block; background: #4CAF50; color: white; padding: 20px 40px; border-radius: 10px; text-decoration: none; font-weight: 700; font-size: 1.2em;">
            üéÆ Play the Feedforward NN Game ‚Üí
        </a>
    </div>
</div>

<script>
const canvas = document.getElementById('networkCanvas');
const ctx = canvas.getContext('2d');

const layers = [
    { neurons: 3, x: 100, label: 'Input' },
    { neurons: 5, x: 300, label: 'Hidden 1' },
    { neurons: 4, x: 500, label: 'Hidden 2' },
    { neurons: 2, x: 700, label: 'Output' }
];

let animating = false;
let animationStep = 0;

function drawNetwork() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw connections first
    for (let i = 0; i < layers.length - 1; i++) {
        const currentLayer = layers[i];
        const nextLayer = layers[i + 1];

        for (let j = 0; j < currentLayer.neurons; j++) {
            const y1 = getY(j, currentLayer.neurons);
            for (let k = 0; k < nextLayer.neurons; k++) {
                const y2 = getY(k, nextLayer.neurons);
                ctx.strokeStyle = animating && i < animationStep ? '#667eea' : '#ddd';
                ctx.lineWidth = animating && i < animationStep ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(currentLayer.x, y1);
                ctx.lineTo(nextLayer.x, y2);
                ctx.stroke();
            }
        }
    }

    // Draw neurons
    layers.forEach((layer, layerIdx) => {
        for (let i = 0; i < layer.neurons; i++) {
            const y = getY(i, layer.neurons);
            ctx.fillStyle = animating && layerIdx <= animationStep ? '#667eea' : '#fff';
            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(layer.x, y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
        }

        // Draw labels
        ctx.fillStyle = '#2d3748';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(layer.label, layer.x, 30);
    });
}

function getY(index, total) {
    const spacing = 60;
    const startY = (canvas.height - (total - 1) * spacing) / 2;
    return startY + index * spacing;
}

function animate() {
    if (animating) return;
    animating = true;
    animationStep = 0;

    const interval = setInterval(() => {
        animationStep++;
        drawNetwork();

        if (animationStep >= layers.length) {
            animating = false;
            clearInterval(interval);
        }
    }, 500);
}

function reset() {
    animating = false;
    animationStep = 0;
    drawNetwork();
}

// Initial draw
drawNetwork();
</script>
</body>
</html>
