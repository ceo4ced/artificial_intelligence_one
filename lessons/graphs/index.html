<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Graphs - Networks, Connections, and Relationships</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 0; }
.nav-header { background: #2d3748; padding: 15px 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex; justify-content: space-between; align-items: center; }
.nav-header a { color: #90cdf4; text-decoration: none; font-weight: 600; font-size: 1.1em; }
.nav-title { color: #fff; font-size: 1.2em; font-weight: 700; }
.container { max-width: 1400px; margin: 20px auto; background: #fff; border-radius: 15px; padding: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
h1 { text-align: center; color: #2d3748; font-size: 2.5em; margin-bottom: 20px; }
.intro { background: #e3f2fd; padding: 20px; border-radius: 10px; margin-bottom: 30px; line-height: 1.6; }
.intro h2 { color: #1976d2; margin-bottom: 10px; }
.main-content { display: grid; grid-template-columns: 350px 1fr; gap: 30px; }
.sidebar { background: #f8f9fa; padding: 20px; border-radius: 10px; height: fit-content; }
button { width: 100%; padding: 12px; margin: 5px 0; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; }
.btn-primary { background: #4CAF50; color: #fff; }
.btn-secondary { background: #2196F3; color: #fff; }
.btn-danger { background: #f44336; color: #fff; }
canvas { border: 2px solid #ddd; border-radius: 8px; display: block; background: #fafafa; margin: 0 auto; }
.explanation { background: #fff9c4; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #fbc02d; }
.explanation h4 { color: #f57c00; margin-bottom: 8px; }
.code-block { background: #2d3748; color: #fff; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.9em; margin: 10px 0; overflow-x: auto; }
.step-info { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; padding: 15px; border-radius: 10px; margin: 15px 0; }
.example-section { margin: 20px 0; }
.example-section h3 { color: #2d3748; margin-bottom: 15px; }
.key-concepts { background: #e8f5e9; padding: 15px; border-radius: 8px; margin: 15px 0; }
.key-concepts ul { margin-left: 20px; line-height: 1.8; }
.graph-type-selector { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 15px 0; }
.graph-btn { padding: 10px; border: 2px solid #667eea; background: #fff; color: #667eea; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s; text-align: center; font-size: 0.9em; }
.graph-btn:hover { background: #667eea; color: #fff; }
.graph-btn.active { background: #667eea; color: #fff; }
.game-link { background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: #fff; padding: 20px; border-radius: 10px; margin-top: 30px; text-align: center; }
.game-link h3 { margin-bottom: 10px; }
.game-link a { color: #fff; text-decoration: none; font-weight: 600; font-size: 1.2em; display: inline-block; background: rgba(255,255,255,0.2); padding: 12px 30px; border-radius: 8px; margin-top: 10px; transition: all 0.3s; }
.game-link a:hover { background: rgba(255,255,255,0.3); transform: scale(1.05); }
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">Graphs - Networks and Connections</div>
    <a href="../../index.html">← Back to Home</a>
</nav>
<div class="container">
    <h1>Graphs - Networks, Connections, and Relationships</h1>

    <div class="intro">
        <h2>What are Graphs?</h2>
        <p>
            In computer science, a graph is a data structure that represents relationships between objects.
            A graph consists of <strong>nodes</strong> (also called vertices) connected by <strong>edges</strong> (also called links).
            Graphs are everywhere: social networks, maps, the internet, recommendation systems, and more.
            Understanding graphs helps us model and solve complex real-world problems involving connections and relationships.
        </p>
    </div>

    <div class="main-content">
        <div class="sidebar">
            <h3>Graph Types</h3>
            <div class="graph-type-selector">
                <button class="graph-btn active" onclick="showGraph('undirected')">Undirected</button>
                <button class="graph-btn" onclick="showGraph('directed')">Directed</button>
                <button class="graph-btn" onclick="showGraph('weighted')">Weighted</button>
                <button class="graph-btn" onclick="showGraph('cyclic')">Cyclic</button>
            </div>

            <button class="btn-primary" onclick="addRandomNode()">Add Random Node</button>
            <button class="btn-secondary" onclick="addRandomEdge()">Add Random Edge</button>
            <button class="btn-danger" onclick="resetGraph()">Clear Graph</button>

            <div class="step-info" id="graphInfo">
                <h4>Graph Info:</h4>
                <p id="infoText">Nodes: 0<br>Edges: 0<br>Type: Undirected</p>
            </div>

            <div class="key-concepts">
                <h4>Key Concepts:</h4>
                <ul>
                    <li><strong>Node/Vertex:</strong> A point in the graph</li>
                    <li><strong>Edge/Link:</strong> Connection between nodes</li>
                    <li><strong>Degree:</strong> Number of edges connected to a node</li>
                    <li><strong>Path:</strong> Sequence of connected nodes</li>
                    <li><strong>Cycle:</strong> Path that starts and ends at same node</li>
                </ul>
            </div>
        </div>

        <div>
            <canvas id="canvas" width="900" height="500"></canvas>

            <div class="explanation">
                <h4>Graph Types:</h4>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><strong>Undirected Graph:</strong> Edges have no direction - relationships are bidirectional (e.g., friendships on Facebook)</li>
                    <li><strong>Directed Graph (Digraph):</strong> Edges have direction - relationships go one way (e.g., Twitter follows, web links)</li>
                    <li><strong>Weighted Graph:</strong> Edges have values/costs (e.g., distances between cities, connection strength)</li>
                    <li><strong>Cyclic Graph:</strong> Contains at least one cycle - you can return to a starting node by following edges</li>
                </ul>
            </div>

            <div class="example-section">
                <h3>Real-World Examples:</h3>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 10px;">
                    <div style="background: #e3f2fd; padding: 15px; border-radius: 8px;">
                        <strong>Social Networks</strong>
                        <p style="margin-top: 8px; font-size: 0.9em;">People are nodes, friendships/follows are edges. Find mutual friends, suggest connections, measure influence.</p>
                    </div>
                    <div style="background: #f3e5f5; padding: 15px; border-radius: 8px;">
                        <strong>Maps & Navigation</strong>
                        <p style="margin-top: 8px; font-size: 0.9em;">Cities are nodes, roads are weighted edges. Find shortest paths, optimize routes, plan trips.</p>
                    </div>
                    <div style="background: #e8f5e9; padding: 15px; border-radius: 8px;">
                        <strong>Recommendation Systems</strong>
                        <p style="margin-top: 8px; font-size: 0.9em;">Users and items as nodes, edges show preferences. Recommend movies, products, or content based on connections.</p>
                    </div>
                    <div style="background: #fff3e0; padding: 15px; border-radius: 8px;">
                        <strong>Web & Internet</strong>
                        <p style="margin-top: 8px; font-size: 0.9em;">Web pages are nodes, hyperlinks are directed edges. PageRank algorithm, web crawling, SEO.</p>
                    </div>
                </div>
            </div>

            <div class="code-block">
<pre>// Common Graph Algorithms:

// 1. Breadth-First Search (BFS) - Explore level by level
function BFS(graph, start):
    queue = [start]
    visited = new Set([start])
    while queue is not empty:
        node = queue.dequeue()
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.enqueue(neighbor)

// 2. Depth-First Search (DFS) - Explore as deep as possible
function DFS(graph, node, visited = new Set()):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            DFS(graph, neighbor, visited)

// 3. Dijkstra's Algorithm - Find shortest path in weighted graph
function dijkstra(graph, start):
    distances = {node: Infinity for all nodes}
    distances[start] = 0
    pq = PriorityQueue()
    pq.add(start, 0)

    while pq is not empty:
        current = pq.extractMin()
        for neighbor, weight in graph[current]:
            distance = distances[current] + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                pq.add(neighbor, distance)

    return distances</pre>
            </div>

            <div class="example-section">
                <h3>Graph Properties & Concepts:</h3>
                <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; line-height: 1.8;">
                    <p><strong>Connected Graph:</strong> There's a path between every pair of nodes</p>
                    <p><strong>Complete Graph:</strong> Every node is connected to every other node</p>
                    <p><strong>Tree:</strong> Connected graph with no cycles (N nodes, N-1 edges)</p>
                    <p><strong>Bipartite Graph:</strong> Nodes can be divided into two groups where edges only connect nodes from different groups</p>
                    <p><strong>Shortest Path:</strong> Path with minimum total edge weight between two nodes</p>
                    <p><strong>Strongly Connected (Directed):</strong> Every node can reach every other node</p>
                </div>
            </div>

            <div class="game-link">
                <h3>Ready to Practice?</h3>
                <p>Build your own graphs and solve real-world challenges!</p>
                <a href="../../games/graphs/index.html">Play Graph Your World Game →</a>
            </div>
        </div>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let nodes = [];
let edges = [];
let graphType = 'undirected';
let nodeIdCounter = 0;

class Node {
    constructor(x, y, id) {
        this.x = x;
        this.y = y;
        this.id = id;
        this.label = String.fromCharCode(65 + id); // A, B, C...
        this.radius = 25;
    }

    draw() {
        ctx.fillStyle = '#667eea';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.label, this.x, this.y);
    }

    contains(x, y) {
        return Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2) <= this.radius;
    }
}

class Edge {
    constructor(from, to, weight = null, directed = false) {
        this.from = from;
        this.to = to;
        this.weight = weight;
        this.directed = directed;
    }

    draw() {
        const fromNode = nodes.find(n => n.id === this.from);
        const toNode = nodes.find(n => n.id === this.to);
        if (!fromNode || !toNode) return;

        ctx.strokeStyle = '#2d3748';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(fromNode.x, fromNode.y);
        ctx.lineTo(toNode.x, toNode.y);
        ctx.stroke();

        // Draw arrow for directed edges
        if (this.directed) {
            const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
            const arrowX = toNode.x - 30 * Math.cos(angle);
            const arrowY = toNode.y - 30 * Math.sin(angle);

            ctx.fillStyle = '#2d3748';
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - 10 * Math.cos(angle - Math.PI / 6), arrowY - 10 * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(arrowX - 10 * Math.cos(angle + Math.PI / 6), arrowY - 10 * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        // Draw weight for weighted edges
        if (this.weight !== null) {
            const midX = (fromNode.x + toNode.x) / 2;
            const midY = (fromNode.y + toNode.y) / 2;

            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(midX, midY, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#2d3748';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.weight, midX, midY);
        }
    }
}

function showGraph(type) {
    graphType = type;
    document.querySelectorAll('.graph-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');

    resetGraph();

    // Create example graphs for each type
    if (type === 'undirected') {
        createUndirectedExample();
    } else if (type === 'directed') {
        createDirectedExample();
    } else if (type === 'weighted') {
        createWeightedExample();
    } else if (type === 'cyclic') {
        createCyclicExample();
    }

    draw();
    updateInfo();
}

function createUndirectedExample() {
    nodes = [
        new Node(200, 150, 0),
        new Node(400, 150, 1),
        new Node(600, 150, 2),
        new Node(300, 300, 3),
        new Node(500, 300, 4)
    ];
    nodeIdCounter = 5;

    edges = [
        new Edge(0, 1, null, false),
        new Edge(1, 2, null, false),
        new Edge(0, 3, null, false),
        new Edge(1, 3, null, false),
        new Edge(1, 4, null, false),
        new Edge(2, 4, null, false)
    ];
}

function createDirectedExample() {
    nodes = [
        new Node(250, 150, 0),
        new Node(450, 150, 1),
        new Node(650, 150, 2),
        new Node(350, 300, 3),
        new Node(550, 300, 4)
    ];
    nodeIdCounter = 5;

    edges = [
        new Edge(0, 1, null, true),
        new Edge(1, 2, null, true),
        new Edge(2, 4, null, true),
        new Edge(1, 3, null, true),
        new Edge(3, 0, null, true),
        new Edge(4, 1, null, true)
    ];
}

function createWeightedExample() {
    nodes = [
        new Node(200, 200, 0),
        new Node(400, 150, 1),
        new Node(600, 200, 2),
        new Node(400, 350, 3)
    ];
    nodeIdCounter = 4;

    edges = [
        new Edge(0, 1, 5, false),
        new Edge(1, 2, 3, false),
        new Edge(2, 3, 7, false),
        new Edge(3, 0, 4, false),
        new Edge(0, 2, 10, false),
        new Edge(1, 3, 6, false)
    ];
}

function createCyclicExample() {
    nodes = [
        new Node(300, 150, 0),
        new Node(500, 150, 1),
        new Node(600, 300, 2),
        new Node(400, 400, 3),
        new Node(200, 300, 4)
    ];
    nodeIdCounter = 5;

    edges = [
        new Edge(0, 1, null, true),
        new Edge(1, 2, null, true),
        new Edge(2, 3, null, true),
        new Edge(3, 4, null, true),
        new Edge(4, 0, null, true),
        new Edge(1, 3, null, true)
    ];
}

function addRandomNode() {
    const x = 100 + Math.random() * (canvas.width - 200);
    const y = 100 + Math.random() * (canvas.height - 200);

    // Check for overlap
    let overlaps = false;
    for (let node of nodes) {
        if (Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2) < 60) {
            overlaps = true;
            break;
        }
    }

    if (!overlaps && nodes.length < 26) {
        nodes.push(new Node(x, y, nodeIdCounter++));
        draw();
        updateInfo();
    }
}

function addRandomEdge() {
    if (nodes.length < 2) return;

    const from = nodes[Math.floor(Math.random() * nodes.length)];
    const to = nodes[Math.floor(Math.random() * nodes.length)];

    if (from.id === to.id) return;

    // Check if edge already exists
    const exists = edges.some(e =>
        (e.from === from.id && e.to === to.id) ||
        (!e.directed && e.from === to.id && e.to === from.id)
    );

    if (!exists) {
        const weight = graphType === 'weighted' ? Math.floor(Math.random() * 10) + 1 : null;
        const directed = graphType === 'directed' || graphType === 'cyclic';
        edges.push(new Edge(from.id, to.id, weight, directed));
        draw();
        updateInfo();
    }
}

function resetGraph() {
    nodes = [];
    edges = [];
    nodeIdCounter = 0;
    draw();
    updateInfo();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw edges first
    edges.forEach(edge => edge.draw());

    // Draw nodes on top
    nodes.forEach(node => node.draw());
}

function updateInfo() {
    let typeText = graphType.charAt(0).toUpperCase() + graphType.slice(1);
    document.getElementById('infoText').innerHTML =
        `Nodes: ${nodes.length}<br>Edges: ${edges.length}<br>Type: ${typeText}`;
}

// Initialize with undirected example
createUndirectedExample();
draw();
updateInfo();
</script>
</body>
</html>
