<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crossword Puzzle Solver</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 0; }
.nav-header { background: #2d3748; padding: 15px 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex; justify-content: space-between; align-items: center; }
.nav-header a { color: #90cdf4; text-decoration: none; font-weight: 600; font-size: 1.1em; }
.nav-title { color: #fff; font-size: 1.2em; font-weight: 700; }
.container { max-width: 1400px; margin: 20px auto; background: #fff; border-radius: 15px; padding: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
h1 { text-align: center; color: #2d3748; font-size: 2.5em; margin-bottom: 30px; }
.main-content { display: grid; grid-template-columns: 320px 1fr; gap: 30px; }
.sidebar { background: #f8f9fa; padding: 20px; border-radius: 10px; height: fit-content; }
button { width: 100%; padding: 12px; margin: 5px 0; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; }
.btn-primary { background: #4CAF50; color: #fff; }
.btn-secondary { background: #2196F3; color: #fff; }
.btn-danger { background: #f44336; color: #fff; }
.puzzle-container { display: flex; justify-content: center; }
.crossword-grid { display: inline-grid; gap: 2px; background: #2d3748; padding: 2px; border-radius: 8px; }
.crossword-cell { width: 35px; height: 35px; background: #fff; display: flex; align-items: center; justify-content: center; font-size: 1.1em; font-weight: bold; border: 1px solid #ccc; position: relative; }
.crossword-cell.blocked { background: #2d3748; }
.crossword-cell.filled { background: #c8e6c9; animation: fadeIn 0.3s; }
.crossword-cell.current { background: #fff9c4; }
.cell-number { position: absolute; top: 2px; left: 3px; font-size: 0.6em; color: #666; font-weight: normal; }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
.stats { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; padding: 15px; border-radius: 10px; margin-top: 15px; }
.stat-row { display: flex; justify-content: space-between; margin: 8px 0; }
.clues { background: #e3f2fd; padding: 15px; border-radius: 8px; margin-top: 15px; max-height: 300px; overflow-y: auto; }
.clues h4 { margin-bottom: 10px; color: #1976d2; }
.clue { font-size: 0.9em; margin: 5px 0; line-height: 1.4; }
.clue strong { color: #333; }
.info { background: #fff3cd; padding: 12px; border-radius: 8px; margin-top: 15px; font-size: 0.9em; line-height: 1.5; }
.control-group { margin: 15px 0; }
.control-group label { display: block; margin-bottom: 5px; font-weight: 600; }
.control-group select { width: 100%; padding: 8px; border-radius: 5px; border: 2px solid #ddd; }
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">üìù Crossword</div>
    <a href="../../index.html">‚Üê Back to Home</a>
</nav>
<div class="container">
    <h1>üìù Crossword Puzzle Solver</h1>
    <div class="main-content">
        <div class="sidebar">
            <h3>Controls</h3>
            <button class="btn-primary" onclick="solve()">Solve Puzzle</button>
            <button class="btn-secondary" onclick="step()">Step Through</button>
            <button class="btn-danger" onclick="reset()">Reset</button>

            <div class="control-group">
                <label>Puzzle:</label>
                <select id="puzzleSelect" onchange="loadPuzzle()">
                    <option value="simple">Simple 5x5</option>
                    <option value="medium">Medium 7x7</option>
                </select>
            </div>

            <div class="stats">
                <div class="stat-row"><span>Words Placed:</span><span id="placed">0</span></div>
                <div class="stat-row"><span>Total Words:</span><span id="total">0</span></div>
                <div class="stat-row"><span>Backtracks:</span><span id="backtracks">0</span></div>
                <div class="stat-row"><span>Status:</span><span id="status">Ready</span></div>
            </div>

            <div class="clues" id="clues">
                <h4>Word List</h4>
            </div>

            <div class="info">
                <strong>Crossword CSP:</strong><br>
                Fill the grid with words from the word list so that all words intersect correctly.
                This is a constraint satisfaction problem solved with backtracking.
            </div>
        </div>
        <div class="puzzle-container">
            <div class="crossword-grid" id="grid"></div>
        </div>
    </div>
</div>
<script>
let gridSize = 5;
let grid = [];
let slots = []; // {id, row, col, length, direction, word, clue}
let words = [];
let backtracks = 0;
let stepGenerator = null;
let currentSlot = null;

const puzzles = {
    simple: {
        size: 5,
        pattern: [
            [1,1,1,1,1],
            [1,0,1,0,1],
            [1,1,1,1,1],
            [1,0,1,0,1],
            [1,1,1,1,1]
        ],
        words: ['APPLE', 'PEARS', 'GRAPE', 'PLUM', 'PEACH', 'LEMON'],
        clues: {
            'APPLE': 'A red fruit',
            'PEARS': 'Green or yellow fruit',
            'GRAPE': 'Small purple fruit',
            'PLUM': 'Dark purple stone fruit',
            'PEACH': 'Fuzzy orange fruit',
            'LEMON': 'Sour yellow citrus'
        }
    },
    medium: {
        size: 7,
        pattern: [
            [1,1,1,1,1,0,0],
            [1,0,0,0,1,0,0],
            [1,1,1,1,1,1,1],
            [1,0,0,0,1,0,1],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,0,1],
            [0,0,0,0,1,1,1]
        ],
        words: ['PYTHON', 'JAVA', 'RUBY', 'HTML', 'CODE', 'DATA', 'ARRAY'],
        clues: {
            'PYTHON': 'Popular programming language',
            'JAVA': 'Coffee and code',
            'RUBY': 'Gem of a language',
            'HTML': 'Web markup language',
            'CODE': 'What programmers write',
            'DATA': 'Information to process',
            'ARRAY': 'List data structure'
        }
    }
};

let currentPuzzle = 'simple';

function loadPuzzle() {
    currentPuzzle = document.getElementById('puzzleSelect').value;
    const puzzle = puzzles[currentPuzzle];
    gridSize = puzzle.size;
    grid = puzzle.pattern.map(row => row.map(cell => cell === 1 ? '' : null));
    words = [...puzzle.words];

    extractSlots();
    initGrid();
    displayClues();
    reset();
}

function extractSlots() {
    slots = [];
    let slotId = 1;

    // Find horizontal slots
    for (let row = 0; row < gridSize; row++) {
        let start = -1;
        for (let col = 0; col <= gridSize; col++) {
            if (col < gridSize && grid[row][col] !== null) {
                if (start === -1) start = col;
            } else {
                if (start !== -1 && col - start > 1) {
                    slots.push({
                        id: slotId++,
                        row: row,
                        col: start,
                        length: col - start,
                        direction: 'across',
                        word: null
                    });
                }
                start = -1;
            }
        }
    }

    // Find vertical slots
    for (let col = 0; col < gridSize; col++) {
        let start = -1;
        for (let row = 0; row <= gridSize; row++) {
            if (row < gridSize && grid[row][col] !== null) {
                if (start === -1) start = row;
            } else {
                if (start !== -1 && row - start > 1) {
                    slots.push({
                        id: slotId++,
                        row: start,
                        col: col,
                        length: row - start,
                        direction: 'down',
                        word: null
                    });
                }
                start = -1;
            }
        }
    }
}

function initGrid() {
    const gridEl = document.getElementById('grid');
    gridEl.style.gridTemplateColumns = `repeat(${gridSize}, 35px)`;
    gridEl.innerHTML = '';

    for (let row = 0; row < gridSize; row++) {
        for (let col = 0; col < gridSize; col++) {
            const cell = document.createElement('div');
            cell.className = 'crossword-cell';
            cell.dataset.row = row;
            cell.dataset.col = col;

            if (grid[row][col] === null) {
                cell.classList.add('blocked');
            }

            gridEl.appendChild(cell);
        }
    }
}

function displayClues() {
    const puzzle = puzzles[currentPuzzle];
    const cluesEl = document.getElementById('clues');
    let html = '<h4>Word List</h4>';

    words.forEach(word => {
        const clue = puzzle.clues[word] || 'No clue';
        html += `<div class="clue"><strong>${word}</strong> (${word.length}): ${clue}</div>`;
    });

    cluesEl.innerHTML = html;
}

function canPlaceWord(slot, word) {
    if (slot.length !== word.length) return false;

    const { row, col, direction } = slot;

    for (let i = 0; i < word.length; i++) {
        const r = direction === 'across' ? row : row + i;
        const c = direction === 'across' ? col + i : col;

        if (grid[r][c] !== '' && grid[r][c] !== word[i]) {
            return false;
        }
    }

    return true;
}

function placeWord(slot, word) {
    const { row, col, direction } = slot;

    for (let i = 0; i < word.length; i++) {
        const r = direction === 'across' ? row : row + i;
        const c = direction === 'across' ? col + i : col;
        grid[r][c] = word[i];
    }

    slot.word = word;
}

function removeWord(slot) {
    const { row, col, direction, length } = slot;

    for (let i = 0; i < length; i++) {
        const r = direction === 'across' ? row : row + i;
        const c = direction === 'across' ? col + i : col;

        // Check if this cell is used by another slot
        let usedByOther = false;
        for (let otherSlot of slots) {
            if (otherSlot === slot || !otherSlot.word) continue;

            for (let j = 0; j < otherSlot.length; j++) {
                const or = otherSlot.direction === 'across' ? otherSlot.row : otherSlot.row + j;
                const oc = otherSlot.direction === 'across' ? otherSlot.col + j : otherSlot.col;

                if (or === r && oc === c) {
                    usedByOther = true;
                    break;
                }
            }
            if (usedByOther) break;
        }

        if (!usedByOther) {
            grid[r][c] = '';
        }
    }

    slot.word = null;
}

function solveCrossword(slotIndex = 0, availableWords = [...words]) {
    if (slotIndex === slots.length) {
        return true;
    }

    const slot = slots[slotIndex];

    for (let i = 0; i < availableWords.length; i++) {
        const word = availableWords[i];

        if (canPlaceWord(slot, word)) {
            placeWord(slot, word);

            const newAvailable = [...availableWords];
            newAvailable.splice(i, 1);

            if (solveCrossword(slotIndex + 1, newAvailable)) {
                return true;
            }

            removeWord(slot);
            backtracks++;
        }
    }

    return false;
}

function* solveCrosswordGenerator(slotIndex = 0, availableWords = [...words]) {
    if (slotIndex === slots.length) {
        return true;
    }

    const slot = slots[slotIndex];
    currentSlot = slot;
    yield false;

    for (let i = 0; i < availableWords.length; i++) {
        const word = availableWords[i];

        if (canPlaceWord(slot, word)) {
            placeWord(slot, word);
            yield false;

            const newAvailable = [...availableWords];
            newAvailable.splice(i, 1);

            const result = yield* solveCrosswordGenerator(slotIndex + 1, newAvailable);
            if (result) {
                currentSlot = null;
                return true;
            }

            removeWord(slot);
            backtracks++;
            yield false;
        }
    }

    currentSlot = null;
    return false;
}

function solve() {
    backtracks = 0;
    stepGenerator = null;
    currentSlot = null;
    document.getElementById('status').textContent = 'Solving...';

    // Reset slots
    slots.forEach(slot => slot.word = null);
    grid = puzzles[currentPuzzle].pattern.map(row => row.map(cell => cell === 1 ? '' : null));

    setTimeout(() => {
        const solved = solveCrossword();
        updateBoard();
        updateStats();
        document.getElementById('status').textContent = solved ? 'Solved!' : 'No solution';
    }, 50);
}

function step() {
    if (!stepGenerator) {
        backtracks = 0;
        slots.forEach(slot => slot.word = null);
        grid = puzzles[currentPuzzle].pattern.map(row => row.map(cell => cell === 1 ? '' : null));
        stepGenerator = solveCrosswordGenerator();
        document.getElementById('status').textContent = 'Stepping...';
    }

    const result = stepGenerator.next();
    updateBoard();
    updateStats();

    if (result.done) {
        stepGenerator = null;
        currentSlot = null;
        document.getElementById('status').textContent = result.value ? 'Solved!' : 'No solution';
    }
}

function updateBoard() {
    const cells = document.querySelectorAll('.crossword-cell');
    cells.forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);

        if (grid[row][col] === null) return;

        cell.textContent = grid[row][col];
        cell.classList.remove('filled', 'current');

        if (grid[row][col] !== '') {
            cell.classList.add('filled');
        }

        if (currentSlot) {
            const { row: sr, col: sc, length, direction } = currentSlot;
            for (let i = 0; i < length; i++) {
                const r = direction === 'across' ? sr : sr + i;
                const c = direction === 'across' ? sc + i : sc;
                if (r === row && c === col) {
                    cell.classList.add('current');
                }
            }
        }
    });
}

function updateStats() {
    const placed = slots.filter(s => s.word !== null).length;
    document.getElementById('placed').textContent = placed;
    document.getElementById('total').textContent = slots.length;
    document.getElementById('backtracks').textContent = backtracks;
}

function reset() {
    backtracks = 0;
    stepGenerator = null;
    currentSlot = null;
    slots.forEach(slot => slot.word = null);
    grid = puzzles[currentPuzzle].pattern.map(row => row.map(cell => cell === 1 ? '' : null));
    updateBoard();
    updateStats();
    document.getElementById('status').textContent = 'Ready';
}

loadPuzzle();
</script>
</body>
</html>
