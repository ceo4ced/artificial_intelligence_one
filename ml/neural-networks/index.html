<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neural Networks Visualizer - ML Learning Tool</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 0;
}

.nav-header {
    background: #2d3748;
    padding: 15px 30px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.nav-header a {
    color: #90cdf4;
    text-decoration: none;
    font-weight: 600;
    font-size: 1.1em;
    transition: color 0.3s;
}

.nav-header a:hover {
    color: #63b3ed;
}

.nav-title {
    color: #fff;
    font-size: 1.2em;
    font-weight: 700;
}

.page-wrapper {
    padding: 20px;
}

.container {
    max-width: 1600px;
    margin: 0 auto;
    background: #fff;
    border-radius: 15px;
    padding: 30px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}

h1 {
    text-align: center;
    color: #2d3748;
    margin-bottom: 10px;
    font-size: 2.5em;
}

.subtitle {
    text-align: center;
    color: #4a5568;
    margin-bottom: 30px;
    font-size: 1.1em;
}

.info-section {
    background: #e8f5e9;
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 25px;
    border-left: 5px solid #4CAF50;
}

.info-section h3 {
    color: #2e7d32;
    margin-bottom: 10px;
}

.info-section p {
    color: #1b5e20;
    line-height: 1.6;
    margin-bottom: 8px;
}

.info-section ul {
    list-style-position: inside;
    color: #1b5e20;
    line-height: 1.8;
}

.main-content {
    display: grid;
    grid-template-columns: 320px 1fr 1fr;
    gap: 20px;
    margin-bottom: 30px;
}

.sidebar {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 10px;
    height: fit-content;
}

.sidebar h3 {
    color: #2d3748;
    margin-bottom: 15px;
    font-size: 1.3em;
}

.control-section {
    margin-bottom: 20px;
}

.control-section label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #4a5568;
}

button {
    width: 100%;
    padding: 12px;
    font-size: 14px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 10px;
}

button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.btn-primary {
    background: #4CAF50;
    color: #fff;
}

.btn-primary:hover:not(:disabled) {
    background: #45a049;
}

.btn-secondary {
    background: #2196F3;
    color: #fff;
}

.btn-secondary:hover:not(:disabled) {
    background: #0b7dda;
}

.btn-danger {
    background: #f44336;
    color: #fff;
}

.btn-danger:hover:not(:disabled) {
    background: #da190b;
}

.btn-warning {
    background: #ff9800;
    color: #fff;
}

.class-selector {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 15px;
}

.class-btn {
    padding: 15px;
    border: 3px solid transparent;
    transition: all 0.3s;
}

.class-btn.active {
    border-color: #2d3748;
    transform: scale(1.05);
}

.class-a {
    background: #ef5350;
}

.class-b {
    background: #42a5f5;
}

.slider-control {
    width: 100%;
    margin-bottom: 10px;
}

.slider-value {
    text-align: center;
    font-weight: 600;
    color: #667eea;
    margin-bottom: 10px;
}

.canvas-area {
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    padding: 20px;
}

.canvas-area h3 {
    color: #2d3748;
    margin-bottom: 15px;
}

#dataCanvas {
    display: block;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    cursor: crosshair;
    background: #fafafa;
    margin-bottom: 10px;
}

#networkCanvas {
    display: block;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: #fafafa;
}

#lossCanvas {
    display: block;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: #fafafa;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-top: 15px;
}

.stat-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #fff;
    padding: 12px;
    border-radius: 8px;
    text-align: center;
}

.stat-label {
    font-size: 0.85em;
    opacity: 0.9;
    margin-bottom: 5px;
}

.stat-value {
    font-size: 1.5em;
    font-weight: bold;
}

.dataset-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 15px;
}

.dataset-buttons button {
    font-size: 12px;
    padding: 8px;
}

.mode-indicator {
    background: #e3f2fd;
    padding: 10px;
    border-radius: 6px;
    margin-bottom: 15px;
    font-size: 0.9em;
    font-weight: 600;
    text-align: center;
}

.legend {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 10px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
}

.legend-color {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

select {
    width: 100%;
    padding: 10px;
    border-radius: 6px;
    border: 2px solid #e2e8f0;
    font-size: 14px;
    margin-bottom: 10px;
}

@media (max-width: 1400px) {
    .main-content {
        grid-template-columns: 1fr;
    }

    h1 {
        font-size: 2em;
    }
}
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">üß† Neural Networks Visualizer</div>
    <a href="../../index.html">‚Üê Back to Home</a>
</nav>

<div class="page-wrapper">
    <div class="container">
        <h1>üß† Neural Networks Visualizer</h1>
        <p class="subtitle">Watch a neural network learn to classify data in real-time!</p>

        <div class="info-section">
            <h3>üìö What are Neural Networks?</h3>
            <p>
                Neural networks are computing systems inspired by biological neural networks in animal brains.
                They consist of interconnected nodes (neurons) organized in layers that process information
                by adjusting connection weights through training.
            </p>
            <p><strong>Real-world applications:</strong></p>
            <ul>
                <li>Image recognition and computer vision</li>
                <li>Natural language processing and translation</li>
                <li>Speech recognition and synthesis</li>
                <li>Self-driving car perception systems</li>
            </ul>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <h3>üéÆ Controls</h3>

                <div class="mode-indicator" style="background: #ef5350; color: white;">
                    Selected: Class A (Red)
                </div>

                <div class="control-section">
                    <label>Select Class:</label>
                    <div class="class-selector">
                        <button class="class-btn class-a active" onclick="selectClass('A')">
                            üî¥ Class A
                        </button>
                        <button class="class-btn class-b" onclick="selectClass('B')">
                            üîµ Class B
                        </button>
                    </div>
                </div>

                <div class="control-section">
                    <label>Hidden Layers:</label>
                    <select id="layerSelect" onchange="resetNetwork()">
                        <option value="4">4 neurons</option>
                        <option value="6" selected>6 neurons</option>
                        <option value="8">8 neurons</option>
                    </select>
                </div>

                <div class="control-section">
                    <label>Learning Rate:</label>
                    <div class="slider-value" id="lrValue">0.1</div>
                    <input type="range" class="slider-control" id="lrSlider"
                           min="0.01" max="0.5" step="0.01" value="0.1"
                           oninput="updateLearningRate()">
                </div>

                <div class="control-section">
                    <label>üìä Sample Datasets:</label>
                    <div class="dataset-buttons">
                        <button class="btn-secondary" onclick="loadDataset('linear')">üìè Linear</button>
                        <button class="btn-secondary" onclick="loadDataset('circle')">‚≠ï Circle</button>
                        <button class="btn-secondary" onclick="loadDataset('xor')">‚ùå XOR</button>
                        <button class="btn-secondary" onclick="loadDataset('spiral')">üåÄ Spiral</button>
                    </div>
                </div>

                <button class="btn-primary" id="trainBtn" onclick="toggleTraining()">‚ñ∂Ô∏è Start Training</button>
                <button class="btn-warning" onclick="resetNetwork()">üîÑ Reset Network</button>
                <button class="btn-danger" onclick="clearAll()">üóëÔ∏è Clear All</button>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Epoch</div>
                        <div class="stat-value" id="epochValue">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Loss</div>
                        <div class="stat-value" id="lossValue">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Accuracy</div>
                        <div class="stat-value" id="accuracyValue">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Points</div>
                        <div class="stat-value" id="pointsValue">0</div>
                    </div>
                </div>
            </div>

            <div class="canvas-area">
                <h3>üìä Training Data</h3>
                <canvas id="dataCanvas" width="600" height="500"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ef5350;"></div>
                        <span>Class A</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #42a5f5;"></div>
                        <span>Class B</span>
                    </div>
                </div>
            </div>

            <div>
                <div class="canvas-area" style="margin-bottom: 20px;">
                    <h3>üß† Network Architecture</h3>
                    <canvas id="networkCanvas" width="600" height="300"></canvas>
                </div>

                <div class="canvas-area">
                    <h3>üìâ Training Loss</h3>
                    <canvas id="lossCanvas" width="600" height="200"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
const dataCanvas = document.getElementById('dataCanvas');
const dataCtx = dataCanvas.getContext('2d');
const networkCanvas = document.getElementById('networkCanvas');
const networkCtx = networkCanvas.getContext('2d');
const lossCanvas = document.getElementById('lossCanvas');
const lossCtx = lossCanvas.getContext('2d');

let points = [];
let selectedClass = 'A';
let learningRate = 0.1;
let isTraining = false;
let epoch = 0;
let lossHistory = [];

// Neural network
let weights1, biases1, weights2, biases2;
let hiddenSize = 6;

const PADDING = 40;
const DATA_WIDTH = dataCanvas.width - 2 * PADDING;
const DATA_HEIGHT = dataCanvas.height - 2 * PADDING;

function initializeNetwork() {
    // Xavier initialization
    weights1 = Array(2).fill(0).map(() =>
        Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * Math.sqrt(2.0 / 2))
    );
    biases1 = Array(hiddenSize).fill(0);

    weights2 = Array(hiddenSize).fill(0).map(() => (Math.random() - 0.5) * Math.sqrt(2.0 / hiddenSize));
    biases2 = 0;

    epoch = 0;
    lossHistory = [];
}

function sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
}

function relu(x) {
    return Math.max(0, x);
}

function forward(x, y) {
    // Hidden layer with ReLU
    const hidden = [];
    for (let i = 0; i < hiddenSize; i++) {
        const z = weights1[0][i] * x + weights1[1][i] * y + biases1[i];
        hidden.push(relu(z));
    }

    // Output layer with sigmoid
    let output = biases2;
    for (let i = 0; i < hiddenSize; i++) {
        output += weights2[i] * hidden[i];
    }
    output = sigmoid(output);

    return { hidden, output };
}

function train() {
    if (points.length === 0) return;

    // Mini-batch training
    for (let iter = 0; iter < 5; iter++) {
        let totalLoss = 0;

        points.forEach(point => {
            const x = point.x / 100;
            const y = point.y / 100;
            const target = point.class === 'A' ? 0 : 1;

            // Forward pass
            const { hidden, output } = forward(x, y);

            // Calculate loss (binary cross-entropy)
            const loss = -(target * Math.log(output + 1e-10) + (1 - target) * Math.log(1 - output + 1e-10));
            totalLoss += loss;

            // Backward pass
            const outputError = output - target;

            // Update output layer
            for (let i = 0; i < hiddenSize; i++) {
                weights2[i] -= learningRate * outputError * hidden[i];
            }
            biases2 -= learningRate * outputError;

            // Update hidden layer
            for (let i = 0; i < hiddenSize; i++) {
                const hiddenError = outputError * weights2[i];
                // ReLU derivative
                if (hidden[i] > 0) {
                    weights1[0][i] -= learningRate * hiddenError * x;
                    weights1[1][i] -= learningRate * hiddenError * y;
                    biases1[i] -= learningRate * hiddenError;
                }
            }
        });

        if (iter === 4) {
            lossHistory.push(totalLoss / points.length);
        }
    }

    epoch++;
    updateStats();
}

function drawDataCanvas() {
    dataCtx.clearRect(0, 0, dataCanvas.width, dataCanvas.height);

    // Draw decision boundary background
    if (weights1 && points.length > 0) {
        const resolution = 5;
        for (let px = 0; px < DATA_WIDTH; px += resolution) {
            for (let py = 0; py < DATA_HEIGHT; py += resolution) {
                const x = px / DATA_WIDTH;
                const y = 1 - py / DATA_HEIGHT;

                const { output } = forward(x, y);

                const alpha = 0.15;
                if (output < 0.5) {
                    dataCtx.fillStyle = `rgba(239, 83, 80, ${alpha})`;
                } else {
                    dataCtx.fillStyle = `rgba(66, 165, 245, ${alpha})`;
                }

                dataCtx.fillRect(PADDING + px, PADDING + py, resolution, resolution);
            }
        }
    }

    // Draw grid
    dataCtx.strokeStyle = '#e2e8f0';
    dataCtx.lineWidth = 1;

    for (let i = 0; i <= 10; i++) {
        const x = PADDING + (DATA_WIDTH / 10) * i;
        dataCtx.beginPath();
        dataCtx.moveTo(x, PADDING);
        dataCtx.lineTo(x, PADDING + DATA_HEIGHT);
        dataCtx.stroke();
    }

    for (let i = 0; i <= 10; i++) {
        const y = PADDING + (DATA_HEIGHT / 10) * i;
        dataCtx.beginPath();
        dataCtx.moveTo(PADDING, y);
        dataCtx.lineTo(PADDING + DATA_WIDTH, y);
        dataCtx.stroke();
    }

    // Draw axes
    dataCtx.strokeStyle = '#2d3748';
    dataCtx.lineWidth = 2;

    dataCtx.beginPath();
    dataCtx.moveTo(PADDING, PADDING + DATA_HEIGHT);
    dataCtx.lineTo(PADDING + DATA_WIDTH, PADDING + DATA_HEIGHT);
    dataCtx.stroke();

    dataCtx.beginPath();
    dataCtx.moveTo(PADDING, PADDING);
    dataCtx.lineTo(PADDING, PADDING + DATA_HEIGHT);
    dataCtx.stroke();

    // Draw points
    points.forEach(point => {
        const x = PADDING + (point.x / 100) * DATA_WIDTH;
        const y = PADDING + DATA_HEIGHT - (point.y / 100) * DATA_HEIGHT;

        dataCtx.fillStyle = point.class === 'A' ? '#ef5350' : '#42a5f5';
        dataCtx.beginPath();
        dataCtx.arc(x, y, 6, 0, Math.PI * 2);
        dataCtx.fill();

        dataCtx.strokeStyle = '#fff';
        dataCtx.lineWidth = 2;
        dataCtx.stroke();
    });
}

function drawNetworkCanvas() {
    networkCtx.clearRect(0, 0, networkCanvas.width, networkCanvas.height);

    const layerX = [100, 300, 500];
    const inputNeurons = 2;
    const outputNeurons = 1;

    // Draw connections with weights
    function drawConnections(x1, y1Array, x2, y2Array, weights) {
        y1Array.forEach((y1, i) => {
            y2Array.forEach((y2, j) => {
                const weight = weights[i][j];
                const strength = Math.min(Math.abs(weight) * 2, 1);

                networkCtx.strokeStyle = weight > 0 ?
                    `rgba(76, 175, 80, ${strength})` :
                    `rgba(244, 67, 54, ${strength})`;
                networkCtx.lineWidth = 1 + strength * 2;

                networkCtx.beginPath();
                networkCtx.moveTo(x1, y1);
                networkCtx.lineTo(x2, y2);
                networkCtx.stroke();
            });
        });
    }

    // Calculate neuron positions
    const inputY = [100, 200];
    const hiddenY = Array(hiddenSize).fill(0).map((_, i) =>
        50 + (networkCanvas.height - 100) * i / (hiddenSize - 1)
    );
    const outputY = [150];

    // Draw connections
    if (weights1) {
        drawConnections(layerX[0], inputY, layerX[1], hiddenY, weights1);
        drawConnections(layerX[1], hiddenY, layerX[2], outputY, [weights2]);
    }

    // Draw neurons
    function drawNeuron(x, y, label, activation = 0) {
        const radius = 20;

        // Neuron circle
        networkCtx.fillStyle = activation > 0 ? `rgba(76, 175, 80, ${Math.min(activation, 1)})` : '#fff';
        networkCtx.strokeStyle = '#667eea';
        networkCtx.lineWidth = 3;

        networkCtx.beginPath();
        networkCtx.arc(x, y, radius, 0, Math.PI * 2);
        networkCtx.fill();
        networkCtx.stroke();

        // Label
        networkCtx.fillStyle = '#2d3748';
        networkCtx.font = 'bold 12px Arial';
        networkCtx.textAlign = 'center';
        networkCtx.textBaseline = 'middle';
        networkCtx.fillText(label, x, y);
    }

    // Input layer
    drawNeuron(layerX[0], inputY[0], 'X');
    drawNeuron(layerX[0], inputY[1], 'Y');

    // Hidden layer
    hiddenY.forEach((y, i) => {
        drawNeuron(layerX[1], y, `H${i + 1}`);
    });

    // Output layer
    drawNeuron(layerX[2], outputY[0], 'Out');

    // Labels
    networkCtx.fillStyle = '#4a5568';
    networkCtx.font = 'bold 14px Arial';
    networkCtx.fillText('Input', layerX[0], 30);
    networkCtx.fillText('Hidden (ReLU)', layerX[1], 30);
    networkCtx.fillText('Output (Sigmoid)', layerX[2], 30);
}

function drawLossCanvas() {
    lossCtx.clearRect(0, 0, lossCanvas.width, lossCanvas.height);

    if (lossHistory.length < 2) {
        lossCtx.fillStyle = '#999';
        lossCtx.font = '14px Arial';
        lossCtx.textAlign = 'center';
        lossCtx.fillText('Training loss will appear here...', lossCanvas.width / 2, lossCanvas.height / 2);
        return;
    }

    const padding = 40;
    const width = lossCanvas.width - 2 * padding;
    const height = lossCanvas.height - 2 * padding;

    // Find max loss for scaling
    const maxLoss = Math.max(...lossHistory);
    const minLoss = Math.min(...lossHistory);
    const lossRange = maxLoss - minLoss || 1;

    // Draw axes
    lossCtx.strokeStyle = '#2d3748';
    lossCtx.lineWidth = 2;

    lossCtx.beginPath();
    lossCtx.moveTo(padding, padding);
    lossCtx.lineTo(padding, padding + height);
    lossCtx.lineTo(padding + width, padding + height);
    lossCtx.stroke();

    // Draw loss curve
    lossCtx.strokeStyle = '#f44336';
    lossCtx.lineWidth = 2;
    lossCtx.beginPath();

    const startIndex = Math.max(0, lossHistory.length - 100);
    const visibleHistory = lossHistory.slice(startIndex);

    visibleHistory.forEach((loss, i) => {
        const x = padding + (i / (visibleHistory.length - 1)) * width;
        const y = padding + height - ((loss - minLoss) / lossRange) * height;

        if (i === 0) {
            lossCtx.moveTo(x, y);
        } else {
            lossCtx.lineTo(x, y);
        }
    });

    lossCtx.stroke();

    // Labels
    lossCtx.fillStyle = '#4a5568';
    lossCtx.font = '12px Arial';
    lossCtx.textAlign = 'center';
    lossCtx.fillText(`Epoch: ${epoch}`, lossCanvas.width / 2, padding + height + 25);
}

function updateStats() {
    document.getElementById('epochValue').textContent = epoch;

    if (lossHistory.length > 0) {
        const currentLoss = lossHistory[lossHistory.length - 1];
        document.getElementById('lossValue').textContent = currentLoss.toFixed(4);
    }

    if (points.length > 0 && weights1) {
        let correct = 0;
        points.forEach(point => {
            const { output } = forward(point.x / 100, point.y / 100);
            const prediction = output < 0.5 ? 'A' : 'B';
            if (prediction === point.class) correct++;
        });

        const accuracy = (correct / points.length * 100).toFixed(1) + '%';
        document.getElementById('accuracyValue').textContent = accuracy;
    }

    document.getElementById('pointsValue').textContent = points.length;
}

function animate() {
    if (isTraining && points.length > 0) {
        train();
        drawDataCanvas();
        drawNetworkCanvas();
        drawLossCanvas();
    }

    requestAnimationFrame(animate);
}

function toggleTraining() {
    if (points.length === 0) {
        alert('Add some data points first!');
        return;
    }

    isTraining = !isTraining;
    const btn = document.getElementById('trainBtn');

    if (isTraining) {
        btn.textContent = '‚è∏Ô∏è Pause Training';
        btn.style.background = '#ff9800';
    } else {
        btn.textContent = '‚ñ∂Ô∏è Resume Training';
        btn.style.background = '#4CAF50';
    }
}

function resetNetwork() {
    hiddenSize = parseInt(document.getElementById('layerSelect').value);
    initializeNetwork();
    isTraining = false;
    document.getElementById('trainBtn').textContent = '‚ñ∂Ô∏è Start Training';
    document.getElementById('trainBtn').style.background = '#4CAF50';
    updateStats();
    drawDataCanvas();
    drawNetworkCanvas();
    drawLossCanvas();
}

function selectClass(cls) {
    selectedClass = cls;

    document.querySelectorAll('.class-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    if (cls === 'A') {
        document.querySelector('.class-a').classList.add('active');
        document.querySelector('.mode-indicator').style.background = '#ef5350';
        document.querySelector('.mode-indicator').textContent = 'Selected: Class A (Red)';
    } else {
        document.querySelector('.class-b').classList.add('active');
        document.querySelector('.mode-indicator').style.background = '#42a5f5';
        document.querySelector('.mode-indicator').textContent = 'Selected: Class B (Blue)';
    }
}

function clearAll() {
    points = [];
    resetNetwork();
}

function updateLearningRate() {
    learningRate = parseFloat(document.getElementById('lrSlider').value);
    document.getElementById('lrValue').textContent = learningRate.toFixed(2);
}

function loadDataset(type) {
    points = [];

    switch(type) {
        case 'linear':
            for (let i = 0; i < 30; i++) {
                points.push({
                    x: 20 + Math.random() * 30,
                    y: 20 + Math.random() * 30,
                    class: 'A'
                });
                points.push({
                    x: 55 + Math.random() * 30,
                    y: 55 + Math.random() * 30,
                    class: 'B'
                });
            }
            break;
        case 'circle':
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 10;
                points.push({
                    x: 50 + radius * Math.cos(angle),
                    y: 50 + radius * Math.sin(angle),
                    class: 'A'
                });
            }
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 28 + Math.random() * 15;
                points.push({
                    x: 50 + radius * Math.cos(angle),
                    y: 50 + radius * Math.sin(angle),
                    class: 'B'
                });
            }
            break;
        case 'xor':
            for (let i = 0; i < 20; i++) {
                points.push({ x: 20 + Math.random() * 25, y: 20 + Math.random() * 25, class: 'A' });
                points.push({ x: 55 + Math.random() * 25, y: 55 + Math.random() * 25, class: 'A' });
                points.push({ x: 20 + Math.random() * 25, y: 55 + Math.random() * 25, class: 'B' });
                points.push({ x: 55 + Math.random() * 25, y: 20 + Math.random() * 25, class: 'B' });
            }
            break;
        case 'spiral':
            for (let i = 0; i < 50; i++) {
                const t = i / 50 * Math.PI * 3;
                const r = 5 + t * 5;
                points.push({
                    x: 50 + r * Math.cos(t) + Math.random() * 3,
                    y: 50 + r * Math.sin(t) + Math.random() * 3,
                    class: 'A'
                });
                points.push({
                    x: 50 + r * Math.cos(t + Math.PI) + Math.random() * 3,
                    y: 50 + r * Math.sin(t + Math.PI) + Math.random() * 3,
                    class: 'B'
                });
            }
            break;
    }

    resetNetwork();
    drawDataCanvas();
}

dataCanvas.addEventListener('click', (e) => {
    const rect = dataCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (x >= PADDING && x <= PADDING + DATA_WIDTH &&
        y >= PADDING && y <= PADDING + DATA_HEIGHT) {

        const dataX = ((x - PADDING) / DATA_WIDTH) * 100;
        const dataY = (1 - (y - PADDING) / DATA_HEIGHT) * 100;

        points.push({
            x: dataX,
            y: dataY,
            class: selectedClass
        });

        updateStats();
        drawDataCanvas();
    }
});

// Initialize
initializeNetwork();
drawDataCanvas();
drawNetworkCanvas();
drawLossCanvas();
updateStats();
animate();
</script>
</body>
</html>
