<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Decision Trees Visualizer - ML Learning Tool</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 0;
}

.nav-header {
    background: #2d3748;
    padding: 15px 30px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.nav-header a {
    color: #90cdf4;
    text-decoration: none;
    font-weight: 600;
    font-size: 1.1em;
    transition: color 0.3s;
}

.nav-header a:hover {
    color: #63b3ed;
}

.nav-title {
    color: #fff;
    font-size: 1.2em;
    font-weight: 700;
}

.page-wrapper {
    padding: 20px;
}

.container {
    max-width: 1600px;
    margin: 0 auto;
    background: #fff;
    border-radius: 15px;
    padding: 30px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}

h1 {
    text-align: center;
    color: #2d3748;
    margin-bottom: 10px;
    font-size: 2.5em;
}

.subtitle {
    text-align: center;
    color: #4a5568;
    margin-bottom: 30px;
    font-size: 1.1em;
}

.info-section {
    background: #e8f5e9;
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 25px;
    border-left: 5px solid #4CAF50;
}

.info-section h3 {
    color: #2e7d32;
    margin-bottom: 10px;
}

.info-section p {
    color: #1b5e20;
    line-height: 1.6;
    margin-bottom: 8px;
}

.info-section ul {
    list-style-position: inside;
    color: #1b5e20;
    line-height: 1.8;
}

.main-content {
    display: grid;
    grid-template-columns: 320px 1fr 400px;
    gap: 20px;
    margin-bottom: 30px;
}

.sidebar {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 10px;
    height: fit-content;
}

.sidebar h3 {
    color: #2d3748;
    margin-bottom: 15px;
    font-size: 1.3em;
}

.control-section {
    margin-bottom: 20px;
}

.control-section label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #4a5568;
}

button {
    width: 100%;
    padding: 12px;
    font-size: 14px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 10px;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

.btn-primary {
    background: #4CAF50;
    color: #fff;
}

.btn-primary:hover {
    background: #45a049;
}

.btn-secondary {
    background: #2196F3;
    color: #fff;
}

.btn-secondary:hover {
    background: #0b7dda;
}

.btn-danger {
    background: #f44336;
    color: #fff;
}

.btn-danger:hover {
    background: #da190b;
}

.class-selector {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 15px;
}

.class-btn {
    padding: 15px;
    border: 3px solid transparent;
    transition: all 0.3s;
}

.class-btn.active {
    border-color: #2d3748;
    transform: scale(1.05);
}

.class-a {
    background: #ef5350;
}

.class-b {
    background: #42a5f5;
}

.canvas-area {
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    padding: 20px;
}

#canvas {
    display: block;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    cursor: crosshair;
    background: #fafafa;
}

.tree-view {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    overflow-y: auto;
    max-height: 700px;
}

.tree-view h3 {
    color: #2d3748;
    margin-bottom: 15px;
}

#treeContainer {
    background: #fff;
    border-radius: 8px;
    padding: 15px;
    min-height: 400px;
}

.tree-node {
    background: #667eea;
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    margin: 8px 0;
    font-size: 13px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.tree-node.leaf {
    background: #4CAF50;
}

.tree-node.leaf-a {
    background: #ef5350;
}

.tree-node.leaf-b {
    background: #42a5f5;
}

.tree-indent {
    margin-left: 30px;
    border-left: 2px solid #ddd;
    padding-left: 10px;
}

.stats-panel {
    background: #fff3cd;
    padding: 15px;
    border-radius: 8px;
    margin-top: 15px;
}

.stats-panel h4 {
    color: #856404;
    margin-bottom: 10px;
}

.stat-item {
    display: flex;
    justify-content: space-between;
    padding: 5px 0;
    color: #856404;
    font-size: 14px;
}

.dataset-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 15px;
}

.dataset-buttons button {
    font-size: 12px;
    padding: 8px;
}

.mode-indicator {
    background: #e3f2fd;
    padding: 10px;
    border-radius: 6px;
    margin-bottom: 15px;
    font-size: 0.9em;
    font-weight: 600;
    text-align: center;
}

.legend {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 10px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
}

.legend-color {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

@media (max-width: 1400px) {
    .main-content {
        grid-template-columns: 1fr;
    }

    h1 {
        font-size: 2em;
    }
}
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">üå≥ Decision Trees Visualizer</div>
    <a href="../../index.html">‚Üê Back to Home</a>
</nav>

<div class="page-wrapper">
    <div class="container">
        <h1>üå≥ Decision Trees Visualizer</h1>
        <p class="subtitle">Add data points and watch the tree learn to classify them!</p>

        <div class="info-section">
            <h3>üìö What are Decision Trees?</h3>
            <p>
                Decision trees are tree-like models that make decisions by asking a series of questions.
                Each internal node represents a "test" on a feature, each branch represents the outcome,
                and each leaf node represents a class label.
            </p>
            <p><strong>Real-world applications:</strong></p>
            <ul>
                <li>Medical diagnosis (symptoms ‚Üí disease)</li>
                <li>Credit approval (applicant data ‚Üí approve/reject)</li>
                <li>Species classification (features ‚Üí species)</li>
                <li>Email spam detection (content ‚Üí spam/not spam)</li>
            </ul>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <h3>üéÆ Controls</h3>

                <div class="mode-indicator" style="background: #ef5350; color: white;">
                    Selected: Class A (Red)
                </div>

                <div class="control-section">
                    <label>Select Class:</label>
                    <div class="class-selector">
                        <button class="class-btn class-a active" onclick="selectClass('A')">
                            üî¥ Class A
                        </button>
                        <button class="class-btn class-b" onclick="selectClass('B')">
                            üîµ Class B
                        </button>
                    </div>
                </div>

                <div class="control-section">
                    <label>üìä Sample Datasets:</label>
                    <div class="dataset-buttons">
                        <button class="btn-secondary" onclick="loadDataset('linearly-separable')">üìè Linear</button>
                        <button class="btn-secondary" onclick="loadDataset('circles')">‚≠ï Circles</button>
                        <button class="btn-secondary" onclick="loadDataset('xor')">‚ùå XOR</button>
                        <button class="btn-secondary" onclick="loadDataset('scattered')">üéØ Scattered</button>
                    </div>
                </div>

                <button class="btn-primary" onclick="buildTree()">üå≥ Build Tree</button>
                <button class="btn-danger" onclick="clearAll()">üóëÔ∏è Clear All</button>

                <div class="stats-panel">
                    <h4>üìà Statistics</h4>
                    <div class="stat-item">
                        <span>Class A Points:</span>
                        <span id="classACount">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Class B Points:</span>
                        <span id="classBCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Tree Depth:</span>
                        <span id="treeDepth">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Accuracy:</span>
                        <span id="accuracy">-</span>
                    </div>
                </div>
            </div>

            <div class="canvas-area">
                <canvas id="canvas" width="700" height="700"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ef5350;"></div>
                        <span>Class A</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #42a5f5;"></div>
                        <span>Class B</span>
                    </div>
                </div>
            </div>

            <div class="tree-view">
                <h3>üå≤ Decision Tree Structure</h3>
                <div id="treeContainer">
                    <p style="color: #999; text-align: center; padding: 40px;">
                        Add points and click "Build Tree" to see the decision tree structure
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let points = [];
let selectedClass = 'A';
let tree = null;

const PADDING = 50;
const WIDTH = canvas.width - 2 * PADDING;
const HEIGHT = canvas.height - 2 * PADDING;

class TreeNode {
    constructor(data) {
        this.data = data;
        this.feature = null;
        this.threshold = null;
        this.left = null;
        this.right = null;
        this.prediction = null;
        this.gini = 0;
        this.samples = 0;
    }
}

function drawGrid() {
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 1;

    for (let i = 0; i <= 10; i++) {
        const x = PADDING + (WIDTH / 10) * i;
        ctx.beginPath();
        ctx.moveTo(x, PADDING);
        ctx.lineTo(x, PADDING + HEIGHT);
        ctx.stroke();
    }

    for (let i = 0; i <= 10; i++) {
        const y = PADDING + (HEIGHT / 10) * i;
        ctx.beginPath();
        ctx.moveTo(PADDING, y);
        ctx.lineTo(PADDING + WIDTH, y);
        ctx.stroke();
    }

    ctx.strokeStyle = '#2d3748';
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(PADDING, PADDING + HEIGHT);
    ctx.lineTo(PADDING + WIDTH, PADDING + HEIGHT);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(PADDING, PADDING);
    ctx.lineTo(PADDING, PADDING + HEIGHT);
    ctx.stroke();
}

function drawPoints() {
    points.forEach(point => {
        const x = PADDING + (point.x / 100) * WIDTH;
        const y = PADDING + HEIGHT - (point.y / 100) * HEIGHT;

        ctx.fillStyle = point.class === 'A' ? '#ef5350' : '#42a5f5';
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
    });
}

function drawDecisionBoundaries(node, xMin, xMax, yMin, yMax, depth = 0) {
    if (!node || !node.feature) return;

    const colors = ['rgba(255, 0, 0, 0.2)', 'rgba(0, 0, 255, 0.2)', 'rgba(0, 255, 0, 0.2)', 'rgba(255, 255, 0, 0.2)'];

    if (node.feature === 0) { // Split on X
        const xCanvas = PADDING + (node.threshold / 100) * WIDTH;

        ctx.strokeStyle = depth % 2 === 0 ? '#ff6b6b' : '#4ecdc4';
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(xCanvas, PADDING + HEIGHT - (yMax / 100) * HEIGHT);
        ctx.lineTo(xCanvas, PADDING + HEIGHT - (yMin / 100) * HEIGHT);
        ctx.stroke();
        ctx.setLineDash([]);

        if (node.left) drawDecisionBoundaries(node.left, xMin, node.threshold, yMin, yMax, depth + 1);
        if (node.right) drawDecisionBoundaries(node.right, node.threshold, xMax, yMin, yMax, depth + 1);
    } else { // Split on Y
        const yCanvas = PADDING + HEIGHT - (node.threshold / 100) * HEIGHT;

        ctx.strokeStyle = depth % 2 === 0 ? '#ff6b6b' : '#4ecdc4';
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(PADDING + (xMin / 100) * WIDTH, yCanvas);
        ctx.lineTo(PADDING + (xMax / 100) * WIDTH, yCanvas);
        ctx.stroke();
        ctx.setLineDash([]);

        if (node.left) drawDecisionBoundaries(node.left, xMin, xMax, yMin, node.threshold, depth + 1);
        if (node.right) drawDecisionBoundaries(node.right, xMin, xMax, node.threshold, yMax, depth + 1);
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    if (tree) {
        drawDecisionBoundaries(tree, 0, 100, 0, 100);
    }
    drawPoints();
}

function calculateGini(data) {
    if (data.length === 0) return 0;

    const classA = data.filter(p => p.class === 'A').length;
    const classB = data.filter(p => p.class === 'B').length;
    const total = data.length;

    const pA = classA / total;
    const pB = classB / total;

    return 1 - (pA * pA + pB * pB);
}

function findBestSplit(data) {
    let bestGini = Infinity;
    let bestFeature = null;
    let bestThreshold = null;

    for (let feature = 0; feature < 2; feature++) {
        const values = data.map(p => feature === 0 ? p.x : p.y).sort((a, b) => a - b);

        for (let i = 0; i < values.length - 1; i++) {
            const threshold = (values[i] + values[i + 1]) / 2;

            const left = data.filter(p => (feature === 0 ? p.x : p.y) <= threshold);
            const right = data.filter(p => (feature === 0 ? p.x : p.y) > threshold);

            if (left.length === 0 || right.length === 0) continue;

            const giniLeft = calculateGini(left);
            const giniRight = calculateGini(right);
            const weightedGini = (left.length / data.length) * giniLeft +
                                 (right.length / data.length) * giniRight;

            if (weightedGini < bestGini) {
                bestGini = weightedGini;
                bestFeature = feature;
                bestThreshold = threshold;
            }
        }
    }

    return { feature: bestFeature, threshold: bestThreshold, gini: bestGini };
}

function buildTreeRecursive(data, depth = 0, maxDepth = 5) {
    const node = new TreeNode(data);
    node.samples = data.length;
    node.gini = calculateGini(data);

    if (data.length === 0) return null;

    const classA = data.filter(p => p.class === 'A').length;
    const classB = data.filter(p => p.class === 'B').length;

    if (classA === 0 || classB === 0 || depth >= maxDepth) {
        node.prediction = classA > classB ? 'A' : 'B';
        return node;
    }

    const split = findBestSplit(data);

    if (!split.feature && split.feature !== 0) {
        node.prediction = classA > classB ? 'A' : 'B';
        return node;
    }

    node.feature = split.feature;
    node.threshold = split.threshold;

    const leftData = data.filter(p =>
        (split.feature === 0 ? p.x : p.y) <= split.threshold
    );
    const rightData = data.filter(p =>
        (split.feature === 0 ? p.x : p.y) > split.threshold
    );

    node.left = buildTreeRecursive(leftData, depth + 1, maxDepth);
    node.right = buildTreeRecursive(rightData, depth + 1, maxDepth);

    return node;
}

function buildTree() {
    if (points.length < 2) {
        alert('Add at least 2 points to build a tree!');
        return;
    }

    tree = buildTreeRecursive(points);
    visualizeTree();
    updateStats();
    draw();
}

function visualizeTree() {
    const container = document.getElementById('treeContainer');
    container.innerHTML = '';

    function renderNode(node, indent = 0) {
        if (!node) return;

        const div = document.createElement('div');
        div.className = 'tree-node';

        if (node.prediction) {
            div.className += node.prediction === 'A' ? ' leaf-a' : ' leaf-b';
            div.textContent = `üçÉ Predict: Class ${node.prediction} (${node.samples} samples, Gini: ${node.gini.toFixed(3)})`;
        } else {
            const featureName = node.feature === 0 ? 'X' : 'Y';
            div.textContent = `üîç ${featureName} <= ${node.threshold.toFixed(1)}? (${node.samples} samples, Gini: ${node.gini.toFixed(3)})`;
        }

        if (indent > 0) {
            const wrapper = document.createElement('div');
            wrapper.className = 'tree-indent';
            wrapper.appendChild(div);
            container.appendChild(wrapper);

            if (node.left) renderNode(node.left, indent + 1);
            if (node.right) renderNode(node.right, indent + 1);
        } else {
            container.appendChild(div);
            if (node.left) renderNode(node.left, indent + 1);
            if (node.right) renderNode(node.right, indent + 1);
        }
    }

    renderNode(tree);
}

function getTreeDepth(node) {
    if (!node) return 0;
    if (node.prediction) return 1;
    return 1 + Math.max(getTreeDepth(node.left), getTreeDepth(node.right));
}

function predictPoint(node, point) {
    if (!node) return null;
    if (node.prediction) return node.prediction;

    const value = node.feature === 0 ? point.x : point.y;
    if (value <= node.threshold) {
        return predictPoint(node.left, point);
    } else {
        return predictPoint(node.right, point);
    }
}

function updateStats() {
    const classA = points.filter(p => p.class === 'A').length;
    const classB = points.filter(p => p.class === 'B').length;

    document.getElementById('classACount').textContent = classA;
    document.getElementById('classBCount').textContent = classB;

    if (tree) {
        document.getElementById('treeDepth').textContent = getTreeDepth(tree);

        let correct = 0;
        points.forEach(point => {
            const prediction = predictPoint(tree, point);
            if (prediction === point.class) correct++;
        });

        const accuracy = points.length > 0 ? (correct / points.length * 100).toFixed(1) + '%' : '-';
        document.getElementById('accuracy').textContent = accuracy;
    } else {
        document.getElementById('treeDepth').textContent = '0';
        document.getElementById('accuracy').textContent = '-';
    }
}

function selectClass(cls) {
    selectedClass = cls;

    document.querySelectorAll('.class-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    if (cls === 'A') {
        document.querySelector('.class-a').classList.add('active');
        document.querySelector('.mode-indicator').style.background = '#ef5350';
        document.querySelector('.mode-indicator').textContent = 'Selected: Class A (Red)';
    } else {
        document.querySelector('.class-b').classList.add('active');
        document.querySelector('.mode-indicator').style.background = '#42a5f5';
        document.querySelector('.mode-indicator').textContent = 'Selected: Class B (Blue)';
    }
}

function clearAll() {
    points = [];
    tree = null;
    document.getElementById('treeContainer').innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">Add points and click "Build Tree" to see the decision tree structure</p>';
    updateStats();
    draw();
}

function loadDataset(type) {
    points = [];

    switch(type) {
        case 'linearly-separable':
            for (let i = 0; i < 20; i++) {
                points.push({
                    x: 20 + Math.random() * 30,
                    y: 20 + Math.random() * 30,
                    class: 'A'
                });
                points.push({
                    x: 55 + Math.random() * 30,
                    y: 55 + Math.random() * 30,
                    class: 'B'
                });
            }
            break;
        case 'circles':
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 10;
                points.push({
                    x: 50 + radius * Math.cos(angle),
                    y: 50 + radius * Math.sin(angle),
                    class: 'A'
                });
            }
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 28 + Math.random() * 15;
                points.push({
                    x: 50 + radius * Math.cos(angle),
                    y: 50 + radius * Math.sin(angle),
                    class: 'B'
                });
            }
            break;
        case 'xor':
            for (let i = 0; i < 15; i++) {
                points.push({ x: 20 + Math.random() * 25, y: 20 + Math.random() * 25, class: 'A' });
                points.push({ x: 55 + Math.random() * 25, y: 55 + Math.random() * 25, class: 'A' });
                points.push({ x: 20 + Math.random() * 25, y: 55 + Math.random() * 25, class: 'B' });
                points.push({ x: 55 + Math.random() * 25, y: 20 + Math.random() * 25, class: 'B' });
            }
            break;
        case 'scattered':
            for (let i = 0; i < 40; i++) {
                points.push({
                    x: Math.random() * 100,
                    y: Math.random() * 100,
                    class: Math.random() > 0.5 ? 'A' : 'B'
                });
            }
            break;
    }

    buildTree();
}

canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (x >= PADDING && x <= PADDING + WIDTH &&
        y >= PADDING && y <= PADDING + HEIGHT) {

        const dataX = ((x - PADDING) / WIDTH) * 100;
        const dataY = ((PADDING + HEIGHT - y) / HEIGHT) * 100;

        points.push({
            x: dataX,
            y: dataY,
            class: selectedClass
        });

        updateStats();
        draw();
    }
});

// Initialize
draw();
updateStats();
</script>
</body>
</html>
