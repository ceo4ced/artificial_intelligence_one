<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Decision Tree Visualizer - ML Learning Tool</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 0;
}

.nav-header {
    background: #2d3748;
    padding: 15px 30px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.nav-header a {
    color: #90cdf4;
    text-decoration: none;
    font-weight: 600;
    font-size: 1.1em;
    transition: color 0.3s;
}

.nav-header a:hover {
    color: #63b3ed;
}

.nav-title {
    color: #fff;
    font-size: 1.2em;
    font-weight: 700;
}

.page-wrapper {
    padding: 20px;
}

.container {
    max-width: 1600px;
    margin: 0 auto;
    background: #fff;
    border-radius: 15px;
    padding: 30px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}

h1 {
    text-align: center;
    color: #2d3748;
    margin-bottom: 10px;
    font-size: 2.5em;
}

.subtitle {
    text-align: center;
    color: #4a5568;
    margin-bottom: 30px;
    font-size: 1.1em;
}

.info-section {
    background: #e8f5e9;
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 25px;
    border-left: 5px solid #4CAF50;
}

.info-section h3 {
    color: #2e7d32;
    margin-bottom: 10px;
}

.info-section p {
    color: #1b5e20;
    line-height: 1.6;
    margin-bottom: 8px;
}

.info-section ul {
    list-style-position: inside;
    color: #1b5e20;
    line-height: 1.8;
}

.main-content {
    display: grid;
    grid-template-columns: 320px 1fr 550px;
    gap: 20px;
    margin-bottom: 30px;
}

.sidebar {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 10px;
    height: fit-content;
}

.sidebar h3 {
    color: #2d3748;
    margin-bottom: 15px;
    font-size: 1.3em;
}

.control-section {
    margin-bottom: 20px;
}

.control-section label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #4a5568;
    font-size: 0.9em;
}

button {
    width: 100%;
    padding: 12px;
    font-size: 14px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 10px;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

.btn-primary {
    background: #4CAF50;
    color: #fff;
}

.btn-primary:hover {
    background: #45a049;
}

.btn-secondary {
    background: #2196F3;
    color: #fff;
}

.btn-secondary:hover {
    background: #0b7dda;
}

.btn-danger {
    background: #f44336;
    color: #fff;
}

.btn-danger:hover {
    background: #da190b;
}

input[type="number"], select {
    width: 100%;
    padding: 8px;
    border: 2px solid #ddd;
    border-radius: 6px;
    font-size: 14px;
    margin-bottom: 10px;
}

.canvas-area {
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    padding: 20px;
}

canvas {
    display: block;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: #fafafa;
}

#dataCanvas {
    cursor: crosshair;
}

.stats-display {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #fff;
    padding: 15px;
    border-radius: 10px;
    margin-top: 15px;
}

.stat-row {
    display: flex;
    justify-content: space-between;
    margin: 8px 0;
    font-size: 0.95em;
}

.stat-value {
    font-weight: bold;
}

.dataset-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 15px;
}

.dataset-buttons button {
    font-size: 12px;
    padding: 8px;
}

.class-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 15px;
}

.btn-active {
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.4);
}

@media (max-width: 1400px) {
    .main-content {
        grid-template-columns: 1fr;
    }
}
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">üå≥ Decision Tree Visualizer</div>
    <a href="../../index.html">‚Üê Back to Home</a>
</nav>

<div class="page-wrapper">
    <div class="container">
        <h1>üå≥ Decision Tree Visualizer</h1>
        <p class="subtitle">Build a decision tree and watch it classify data through branching decisions!</p>

        <div class="info-section">
            <h3>üìö What is a Decision Tree?</h3>
            <p>
                A decision tree is a flowchart-like structure where each internal node represents a test on a feature,
                each branch represents the outcome of the test, and each leaf node represents a class label.
                Decision trees learn by recursively splitting data to maximize information gain.
            </p>
            <p><strong>Real-world applications:</strong></p>
            <ul>
                <li>Medical diagnosis (symptom-based disease prediction)</li>
                <li>Credit approval (risk assessment)</li>
                <li>Customer segmentation (marketing)</li>
                <li>Fraud detection (banking)</li>
                <li>Game AI (decision making)</li>
            </ul>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <h3>üéÆ Controls</h3>

                <div class="control-section">
                    <label>Max Tree Depth:</label>
                    <input type="number" id="maxDepth" value="3" min="1" max="5">
                </div>

                <div class="control-section">
                    <label>Min Samples for Split:</label>
                    <input type="number" id="minSamples" value="2" min="1" max="10">
                </div>

                <div class="control-section">
                    <label>Split Criterion:</label>
                    <select id="criterion">
                        <option value="gini">Gini Impurity</option>
                        <option value="entropy">Information Gain (Entropy)</option>
                    </select>
                </div>

                <button class="btn-primary" onclick="buildTree()">üå≥ Build Decision Tree</button>
                <button class="btn-secondary" onclick="resetTree()">üîÑ Reset Tree</button>

                <div class="control-section" style="margin-top: 20px;">
                    <label>Add Training Data:</label>
                    <div class="class-buttons">
                        <button class="btn-secondary btn-active" id="class0Btn" onclick="setDataClass(0)">üîµ Class 0</button>
                        <button class="btn-danger" id="class1Btn" onclick="setDataClass(1)">üî¥ Class 1</button>
                    </div>
                </div>

                <div class="control-section">
                    <label>üìä Sample Datasets:</label>
                    <div class="dataset-buttons">
                        <button class="btn-secondary" onclick="loadDataset('linear')">üìè Linear</button>
                        <button class="btn-secondary" onclick="loadDataset('quadrants')">‚äû Quadrants</button>
                        <button class="btn-secondary" onclick="loadDataset('diagonal')">‚üã Diagonal</button>
                        <button class="btn-secondary" onclick="loadDataset('complex')">üî∑ Complex</button>
                    </div>
                </div>

                <button class="btn-danger" onclick="clearData()">üóëÔ∏è Clear All Data</button>

                <div class="stats-display">
                    <div class="stat-row">
                        <span>Tree Depth:</span>
                        <span class="stat-value" id="treeDepth">-</span>
                    </div>
                    <div class="stat-row">
                        <span>Total Nodes:</span>
                        <span class="stat-value" id="totalNodes">-</span>
                    </div>
                    <div class="stat-row">
                        <span>Leaf Nodes:</span>
                        <span class="stat-value" id="leafNodes">-</span>
                    </div>
                    <div class="stat-row">
                        <span>Accuracy:</span>
                        <span class="stat-value" id="accuracy">-</span>
                    </div>
                    <div class="stat-row">
                        <span>Data Points:</span>
                        <span class="stat-value" id="dataCount">0</span>
                    </div>
                </div>
            </div>

            <div class="canvas-area">
                <h3>Training Data & Decision Regions</h3>
                <canvas id="dataCanvas" width="550" height="550"></canvas>
            </div>

            <div class="canvas-area">
                <h3>Decision Tree Structure</h3>
                <canvas id="treeCanvas" width="500" height="550"></canvas>
            </div>
        </div>
    </div>
</div>

<script>
const dataCanvas = document.getElementById('dataCanvas');
const dataCtx = dataCanvas.getContext('2d');
const treeCanvas = document.getElementById('treeCanvas');
const treeCtx = treeCanvas.getContext('2d');

let trainingData = [];
let currentClass = 0;
let decisionTree = null;

class TreeNode {
    constructor(depth = 0) {
        this.depth = depth;
        this.feature = null;  // Feature index to split on
        this.threshold = null;  // Threshold value
        this.left = null;  // Left child (feature <= threshold)
        this.right = null;  // Right child (feature > threshold)
        this.label = null;  // Class label for leaf nodes
        this.samples = 0;
        this.impurity = 0;
        this.classDistribution = [0, 0];
    }

    isLeaf() {
        return this.label !== null;
    }
}

class DecisionTreeClassifier {
    constructor(maxDepth = 3, minSamples = 2, criterion = 'gini') {
        this.maxDepth = maxDepth;
        this.minSamples = minSamples;
        this.criterion = criterion;
        this.root = null;
        this.nodeCount = 0;
        this.leafCount = 0;
    }

    calculateImpurity(labels) {
        const n = labels.length;
        if (n === 0) return 0;

        const counts = [0, 0];
        labels.forEach(label => counts[label]++);

        if (this.criterion === 'gini') {
            // Gini impurity
            const p0 = counts[0] / n;
            const p1 = counts[1] / n;
            return 1 - (p0 * p0 + p1 * p1);
        } else {
            // Entropy
            let entropy = 0;
            for (let i = 0; i < 2; i++) {
                if (counts[i] > 0) {
                    const p = counts[i] / n;
                    entropy -= p * Math.log2(p);
                }
            }
            return entropy;
        }
    }

    findBestSplit(data) {
        let bestGain = -Infinity;
        let bestFeature = null;
        let bestThreshold = null;

        const labels = data.map(d => d.label);
        const parentImpurity = this.calculateImpurity(labels);

        // Try splits on both features (x and y)
        for (let feature = 0; feature < 2; feature++) {
            // Get unique values for this feature
            const values = data.map(d => feature === 0 ? d.x : d.y);
            const uniqueValues = [...new Set(values)].sort((a, b) => a - b);

            // Try midpoints between unique values
            for (let i = 0; i < uniqueValues.length - 1; i++) {
                const threshold = (uniqueValues[i] + uniqueValues[i + 1]) / 2;

                const leftData = data.filter(d => (feature === 0 ? d.x : d.y) <= threshold);
                const rightData = data.filter(d => (feature === 0 ? d.x : d.y) > threshold);

                if (leftData.length === 0 || rightData.length === 0) continue;

                const leftLabels = leftData.map(d => d.label);
                const rightLabels = rightData.map(d => d.label);

                const leftImpurity = this.calculateImpurity(leftLabels);
                const rightImpurity = this.calculateImpurity(rightLabels);

                const weightedImpurity =
                    (leftData.length / data.length) * leftImpurity +
                    (rightData.length / data.length) * rightImpurity;

                const gain = parentImpurity - weightedImpurity;

                if (gain > bestGain) {
                    bestGain = gain;
                    bestFeature = feature;
                    bestThreshold = threshold;
                }
            }
        }

        return { feature: bestFeature, threshold: bestThreshold, gain: bestGain };
    }

    buildNode(data, depth) {
        const node = new TreeNode(depth);
        this.nodeCount++;

        node.samples = data.length;
        const labels = data.map(d => d.label);
        labels.forEach(label => node.classDistribution[label]++);
        node.impurity = this.calculateImpurity(labels);

        // Check stopping criteria
        const allSameClass = labels.every(l => l === labels[0]);
        if (allSameClass || depth >= this.maxDepth || data.length < this.minSamples) {
            // Create leaf node
            node.label = node.classDistribution[0] > node.classDistribution[1] ? 0 : 1;
            this.leafCount++;
            return node;
        }

        // Find best split
        const split = this.findBestSplit(data);

        if (split.feature === null || split.gain <= 0) {
            // Cannot split, create leaf
            node.label = node.classDistribution[0] > node.classDistribution[1] ? 0 : 1;
            this.leafCount++;
            return node;
        }

        // Create internal node
        node.feature = split.feature;
        node.threshold = split.threshold;

        const leftData = data.filter(d =>
            (split.feature === 0 ? d.x : d.y) <= split.threshold
        );
        const rightData = data.filter(d =>
            (split.feature === 0 ? d.x : d.y) > split.threshold
        );

        node.left = this.buildNode(leftData, depth + 1);
        node.right = this.buildNode(rightData, depth + 1);

        return node;
    }

    fit(data) {
        this.nodeCount = 0;
        this.leafCount = 0;
        this.root = this.buildNode(data, 0);
    }

    predict(x, y, node = this.root) {
        if (node.isLeaf()) {
            return node.label;
        }

        const value = node.feature === 0 ? x : y;
        if (value <= node.threshold) {
            return this.predict(x, y, node.left);
        } else {
            return this.predict(x, y, node.right);
        }
    }
}

function buildTree() {
    if (trainingData.length < 2) {
        alert('Add at least 2 training points!');
        return;
    }

    const maxDepth = parseInt(document.getElementById('maxDepth').value);
    const minSamples = parseInt(document.getElementById('minSamples').value);
    const criterion = document.getElementById('criterion').value;

    decisionTree = new DecisionTreeClassifier(maxDepth, minSamples, criterion);
    decisionTree.fit(trainingData);

    updateStats();
    drawDataCanvas();
    drawTree();
}

function resetTree() {
    decisionTree = null;
    updateStats();
    drawDataCanvas();
    drawTree();
}

function drawDataCanvas() {
    dataCtx.clearRect(0, 0, dataCanvas.width, dataCanvas.height);

    // Draw decision regions
    if (decisionTree) {
        const resolution = 4;
        for (let x = 0; x < dataCanvas.width; x += resolution) {
            for (let y = 0; y < dataCanvas.height; y += resolution) {
                const dataX = x / dataCanvas.width;
                const dataY = 1 - y / dataCanvas.height;

                const prediction = decisionTree.predict(dataX, dataY);

                const color = prediction === 0 ?
                    'rgba(33, 150, 243, 0.2)' :
                    'rgba(244, 67, 54, 0.2)';

                dataCtx.fillStyle = color;
                dataCtx.fillRect(x, y, resolution, resolution);
            }
        }
    }

    // Draw grid lines
    dataCtx.strokeStyle = '#e2e8f0';
    dataCtx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
        const pos = (i / 10) * dataCanvas.width;
        dataCtx.beginPath();
        dataCtx.moveTo(pos, 0);
        dataCtx.lineTo(pos, dataCanvas.height);
        dataCtx.stroke();
        dataCtx.beginPath();
        dataCtx.moveTo(0, pos);
        dataCtx.lineTo(dataCanvas.width, pos);
        dataCtx.stroke();
    }

    // Draw training data
    trainingData.forEach(point => {
        const x = point.x * dataCanvas.width;
        const y = (1 - point.y) * dataCanvas.height;

        dataCtx.fillStyle = point.label === 0 ? '#2196F3' : '#f44336';
        dataCtx.beginPath();
        dataCtx.arc(x, y, 6, 0, Math.PI * 2);
        dataCtx.fill();

        dataCtx.strokeStyle = '#fff';
        dataCtx.lineWidth = 2;
        dataCtx.stroke();
    });
}

function drawTree() {
    treeCtx.clearRect(0, 0, treeCanvas.width, treeCanvas.height);

    if (!decisionTree || !decisionTree.root) {
        treeCtx.fillStyle = '#999';
        treeCtx.font = '16px Arial';
        treeCtx.textAlign = 'center';
        treeCtx.fillText('Build a tree to see visualization', treeCanvas.width / 2, treeCanvas.height / 2);
        return;
    }

    const nodeRadius = 25;
    const levelHeight = 90;
    const startY = 40;

    function getTreeWidth(node) {
        if (!node) return 0;
        if (node.isLeaf()) return 1;
        return getTreeWidth(node.left) + getTreeWidth(node.right);
    }

    function drawNode(node, x, y, width) {
        if (!node) return;

        // Draw node circle
        const color = node.isLeaf() ?
            (node.label === 0 ? '#2196F3' : '#f44336') :
            '#4CAF50';

        treeCtx.fillStyle = color;
        treeCtx.beginPath();
        treeCtx.arc(x, y, nodeRadius, 0, Math.PI * 2);
        treeCtx.fill();

        treeCtx.strokeStyle = '#2d3748';
        treeCtx.lineWidth = 3;
        treeCtx.stroke();

        // Draw node text
        treeCtx.fillStyle = '#fff';
        treeCtx.font = 'bold 11px Arial';
        treeCtx.textAlign = 'center';
        treeCtx.textBaseline = 'middle';

        if (node.isLeaf()) {
            treeCtx.fillText(`Class ${node.label}`, x, y - 3);
            treeCtx.font = '9px Arial';
            treeCtx.fillText(`n=${node.samples}`, x, y + 8);
        } else {
            const featureName = node.feature === 0 ? 'x' : 'y';
            treeCtx.fillText(`${featureName} ‚â§ ${node.threshold.toFixed(2)}`, x, y - 3);
            treeCtx.font = '9px Arial';
            treeCtx.fillText(`n=${node.samples}`, x, y + 8);
        }

        // Draw children
        if (!node.isLeaf()) {
            const leftWidth = getTreeWidth(node.left);
            const rightWidth = getTreeWidth(node.right);
            const totalWidth = leftWidth + rightWidth;

            const leftX = x - (width / 4) * (rightWidth / Math.max(totalWidth, 1));
            const rightX = x + (width / 4) * (leftWidth / Math.max(totalWidth, 1));
            const childY = y + levelHeight;

            // Draw edges
            treeCtx.strokeStyle = '#667eea';
            treeCtx.lineWidth = 2;

            // Left edge
            treeCtx.beginPath();
            treeCtx.moveTo(x, y + nodeRadius);
            treeCtx.lineTo(leftX, childY - nodeRadius);
            treeCtx.stroke();

            // Right edge
            treeCtx.beginPath();
            treeCtx.moveTo(x, y + nodeRadius);
            treeCtx.lineTo(rightX, childY - nodeRadius);
            treeCtx.stroke();

            // Draw children recursively
            drawNode(node.left, leftX, childY, width / 2);
            drawNode(node.right, rightX, childY, width / 2);
        }
    }

    drawNode(decisionTree.root, treeCanvas.width / 2, startY, treeCanvas.width);
}

function updateStats() {
    document.getElementById('dataCount').textContent = trainingData.length;

    if (decisionTree) {
        document.getElementById('treeDepth').textContent = decisionTree.root.depth;
        document.getElementById('totalNodes').textContent = decisionTree.nodeCount;
        document.getElementById('leafNodes').textContent = decisionTree.leafCount;

        // Calculate accuracy
        let correct = 0;
        trainingData.forEach(point => {
            const prediction = decisionTree.predict(point.x, point.y);
            if (prediction === point.label) correct++;
        });
        const accuracy = ((correct / trainingData.length) * 100).toFixed(1);
        document.getElementById('accuracy').textContent = accuracy + '%';
    } else {
        document.getElementById('treeDepth').textContent = '-';
        document.getElementById('totalNodes').textContent = '-';
        document.getElementById('leafNodes').textContent = '-';
        document.getElementById('accuracy').textContent = '-';
    }
}

function setDataClass(classNum) {
    currentClass = classNum;
    document.getElementById('class0Btn').classList.toggle('btn-active', classNum === 0);
    document.getElementById('class1Btn').classList.toggle('btn-active', classNum === 1);
}

function clearData() {
    trainingData = [];
    decisionTree = null;
    updateStats();
    drawDataCanvas();
    drawTree();
}

function loadDataset(type) {
    trainingData = [];

    switch(type) {
        case 'linear':
            for (let i = 0; i < 40; i++) {
                const x = Math.random();
                const y = Math.random();
                trainingData.push({
                    x: x,
                    y: y,
                    label: x + y > 1 ? 1 : 0
                });
            }
            break;

        case 'quadrants':
            for (let i = 0; i < 50; i++) {
                const x = Math.random();
                const y = Math.random();
                const label = (x > 0.5 && y > 0.5) || (x <= 0.5 && y <= 0.5) ? 0 : 1;
                trainingData.push({ x, y, label });
            }
            break;

        case 'diagonal':
            for (let i = 0; i < 40; i++) {
                const x = Math.random();
                const y = Math.random();
                trainingData.push({
                    x: x,
                    y: y,
                    label: y > x ? 1 : 0
                });
            }
            break;

        case 'complex':
            for (let i = 0; i < 60; i++) {
                const x = Math.random();
                const y = Math.random();
                let label;
                if (x < 0.33) {
                    label = y > 0.5 ? 0 : 1;
                } else if (x < 0.66) {
                    label = y > 0.3 ? 1 : 0;
                } else {
                    label = y > 0.7 ? 0 : 1;
                }
                trainingData.push({ x, y, label });
            }
            break;
    }

    buildTree();
}

dataCanvas.addEventListener('click', (e) => {
    const rect = dataCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / dataCanvas.width;
    const y = 1 - (e.clientY - rect.top) / dataCanvas.height;

    trainingData.push({
        x: x,
        y: y,
        label: currentClass
    });

    updateStats();
    drawDataCanvas();
});

// Initialize
drawDataCanvas();
drawTree();
updateStats();
</script>
</body>
</html>
