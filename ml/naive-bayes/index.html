<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Naive Bayes Visualizer - ML Learning Tool</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 0;
}

.nav-header {
    background: #2d3748;
    padding: 15px 30px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.nav-header a {
    color: #90cdf4;
    text-decoration: none;
    font-weight: 600;
    font-size: 1.1em;
    transition: color 0.3s;
}

.nav-header a:hover {
    color: #63b3ed;
}

.nav-title {
    color: #fff;
    font-size: 1.2em;
    font-weight: 700;
}

.page-wrapper {
    padding: 20px;
}

.container {
    max-width: 1600px;
    margin: 0 auto;
    background: #fff;
    border-radius: 15px;
    padding: 30px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}

h1 {
    text-align: center;
    color: #2d3748;
    margin-bottom: 10px;
    font-size: 2.5em;
}

.subtitle {
    text-align: center;
    color: #4a5568;
    margin-bottom: 30px;
    font-size: 1.1em;
}

.info-section {
    background: #e8f5e9;
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 25px;
    border-left: 5px solid #4CAF50;
}

.info-section h3 {
    color: #2e7d32;
    margin-bottom: 10px;
}

.info-section p {
    color: #1b5e20;
    line-height: 1.6;
    margin-bottom: 8px;
}

.info-section ul {
    list-style-position: inside;
    color: #1b5e20;
    line-height: 1.8;
}

.main-content {
    display: grid;
    grid-template-columns: 320px 1fr;
    gap: 20px;
    margin-bottom: 30px;
}

.sidebar {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 10px;
    height: fit-content;
}

.sidebar h3 {
    color: #2d3748;
    margin-bottom: 15px;
    font-size: 1.3em;
}

.control-section {
    margin-bottom: 20px;
}

.control-section label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #4a5568;
    font-size: 0.9em;
}

button {
    width: 100%;
    padding: 12px;
    font-size: 14px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 10px;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

.btn-primary {
    background: #4CAF50;
    color: #fff;
}

.btn-primary:hover {
    background: #45a049;
}

.btn-secondary {
    background: #2196F3;
    color: #fff;
}

.btn-secondary:hover {
    background: #0b7dda;
}

.btn-danger {
    background: #f44336;
    color: #fff;
}

.btn-danger:hover {
    background: #da190b;
}

.canvas-area {
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    padding: 20px;
}

canvas {
    display: block;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: #fafafa;
    margin-bottom: 15px;
}

#dataCanvas {
    cursor: crosshair;
}

.stats-display {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #fff;
    padding: 15px;
    border-radius: 10px;
    margin-top: 15px;
}

.stat-row {
    display: flex;
    justify-content: space-between;
    margin: 8px 0;
    font-size: 0.95em;
}

.stat-value {
    font-weight: bold;
}

.dataset-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 15px;
}

.dataset-buttons button {
    font-size: 12px;
    padding: 8px;
}

.class-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 15px;
}

.btn-active {
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.4);
}

.prob-display {
    background: #fff3cd;
    padding: 12px;
    border-radius: 6px;
    margin-top: 15px;
    font-size: 0.9em;
}

.prob-row {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    font-weight: 600;
    color: #856404;
}

@media (max-width: 1200px) {
    .main-content {
        grid-template-columns: 1fr;
    }
}
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">üìä Naive Bayes Visualizer</div>
    <a href="../../index.html">‚Üê Back to Home</a>
</nav>

<div class="page-wrapper">
    <div class="container">
        <h1>üìä Naive Bayes Classifier</h1>
        <p class="subtitle">Probabilistic classification using Bayes' Theorem!</p>

        <div class="info-section">
            <h3>üìö What is Naive Bayes?</h3>
            <p>
                Naive Bayes is a probabilistic classifier based on Bayes' Theorem. It assumes features are independent
                (the "naive" assumption) and calculates the probability of each class given the input features.
                Despite its simplicity, it's surprisingly effective for many real-world applications!
            </p>
            <p><strong>Bayes' Theorem:</strong> P(Class|Features) = P(Features|Class) √ó P(Class) / P(Features)</p>
            <p><strong>Real-world applications:</strong></p>
            <ul>
                <li>Email spam filtering (spam vs. not spam)</li>
                <li>Sentiment analysis (positive vs. negative reviews)</li>
                <li>Medical diagnosis (disease probability)</li>
                <li>Document classification (news categorization)</li>
                <li>Weather prediction</li>
            </ul>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <h3>üéÆ Controls</h3>

                <button class="btn-primary" onclick="trainClassifier()">üìä Train Classifier</button>
                <button class="btn-secondary" onclick="resetClassifier()">üîÑ Reset</button>

                <div class="control-section" style="margin-top: 20px;">
                    <label>Add Training Data:</label>
                    <div class="class-buttons">
                        <button class="btn-secondary btn-active" id="class0Btn" onclick="setDataClass(0)">üîµ Class 0</button>
                        <button class="btn-danger" id="class1Btn" onclick="setDataClass(1)">üî¥ Class 1</button>
                    </div>
                </div>

                <div class="control-section">
                    <label>üìä Sample Datasets:</label>
                    <div class="dataset-buttons">
                        <button class="btn-secondary" onclick="loadDataset('separated')">üìè Separated</button>
                        <button class="btn-secondary" onclick="loadDataset('overlapping')">‚äö Overlapping</button>
                        <button class="btn-secondary" onclick="loadDataset('diagonal')">‚üã Diagonal</button>
                        <button class="btn-secondary" onclick="loadDataset('clusters')">üî∑ Clusters</button>
                    </div>
                </div>

                <button class="btn-danger" onclick="clearData()">üóëÔ∏è Clear All Data</button>

                <div class="prob-display" id="probDisplay" style="display: none;">
                    <div style="text-align: center; font-weight: bold; margin-bottom: 10px;">
                        Hover Probabilities
                    </div>
                    <div class="prob-row">
                        <span>P(Class 0):</span>
                        <span id="prob0">-</span>
                    </div>
                    <div class="prob-row">
                        <span>P(Class 1):</span>
                        <span id="prob1">-</span>
                    </div>
                </div>

                <div class="stats-display">
                    <div class="stat-row">
                        <span>Class 0 Prior:</span>
                        <span class="stat-value" id="prior0">-</span>
                    </div>
                    <div class="stat-row">
                        <span>Class 1 Prior:</span>
                        <span class="stat-value" id="prior1">-</span>
                    </div>
                    <div class="stat-row">
                        <span>Accuracy:</span>
                        <span class="stat-value" id="accuracy">-</span>
                    </div>
                    <div class="stat-row">
                        <span>Data Points:</span>
                        <span class="stat-value" id="dataCount">0</span>
                    </div>
                </div>
            </div>

            <div class="canvas-area">
                <h3>Training Data & Probability Map</h3>
                <canvas id="dataCanvas" width="700" height="500"></canvas>

                <h3 style="margin-top: 20px;">Probability Distributions</h3>
                <canvas id="distCanvas" width="700" height="300"></canvas>
            </div>
        </div>
    </div>
</div>

<script>
const dataCanvas = document.getElementById('dataCanvas');
const dataCtx = dataCanvas.getContext('2d');
const distCanvas = document.getElementById('distCanvas');
const distCtx = distCanvas.getContext('2d');

let trainingData = [];
let currentClass = 0;
let classifier = null;

class GaussianNB {
    constructor() {
        this.classes = [0, 1];
        this.priors = {};
        this.means = {};
        this.stds = {};
    }

    fit(data) {
        const class0 = data.filter(d => d.label === 0);
        const class1 = data.filter(d => d.label === 1);

        // Calculate priors
        this.priors[0] = class0.length / data.length;
        this.priors[1] = class1.length / data.length;

        // Calculate means and standard deviations for each feature
        this.means[0] = this.calculateMeans(class0);
        this.means[1] = this.calculateMeans(class1);

        this.stds[0] = this.calculateStds(class0, this.means[0]);
        this.stds[1] = this.calculateStds(class1, this.means[1]);
    }

    calculateMeans(data) {
        if (data.length === 0) return { x: 0, y: 0 };
        const sumX = data.reduce((sum, d) => sum + d.x, 0);
        const sumY = data.reduce((sum, d) => sum + d.y, 0);
        return {
            x: sumX / data.length,
            y: sumY / data.length
        };
    }

    calculateStds(data, means) {
        if (data.length === 0) return { x: 0.1, y: 0.1 };
        const sumSqX = data.reduce((sum, d) => sum + Math.pow(d.x - means.x, 2), 0);
        const sumSqY = data.reduce((sum, d) => sum + Math.pow(d.y - means.y, 2), 0);
        return {
            x: Math.sqrt(sumSqX / data.length) + 0.01, // Add small value to avoid division by zero
            y: Math.sqrt(sumSqY / data.length) + 0.01
        };
    }

    gaussianPDF(x, mean, std) {
        const exponent = -Math.pow(x - mean, 2) / (2 * Math.pow(std, 2));
        return (1 / (std * Math.sqrt(2 * Math.PI))) * Math.exp(exponent);
    }

    predictProba(x, y) {
        const probabilities = {};

        for (const cls of this.classes) {
            // P(Class) * P(x|Class) * P(y|Class)
            const pClass = this.priors[cls];
            const pX = this.gaussianPDF(x, this.means[cls].x, this.stds[cls].x);
            const pY = this.gaussianPDF(y, this.means[cls].y, this.stds[cls].y);

            probabilities[cls] = pClass * pX * pY;
        }

        // Normalize
        const total = probabilities[0] + probabilities[1];
        probabilities[0] /= total;
        probabilities[1] /= total;

        return probabilities;
    }

    predict(x, y) {
        const probs = this.predictProba(x, y);
        return probs[0] > probs[1] ? 0 : 1;
    }
}

function trainClassifier() {
    if (trainingData.length < 2) {
        alert('Add at least 2 training points!');
        return;
    }

    classifier = new GaussianNB();
    classifier.fit(trainingData);

    updateStats();
    drawDataCanvas();
    drawDistributions();
}

function resetClassifier() {
    classifier = null;
    updateStats();
    drawDataCanvas();
    drawDistributions();
}

function drawDataCanvas() {
    dataCtx.clearRect(0, 0, dataCanvas.width, dataCanvas.height);

    // Draw probability heatmap
    if (classifier) {
        const resolution = 5;
        for (let x = 0; x < dataCanvas.width; x += resolution) {
            for (let y = 0; y < dataCanvas.height; y += resolution) {
                const dataX = x / dataCanvas.width;
                const dataY = 1 - y / dataCanvas.height;

                const probs = classifier.predictProba(dataX, dataY);

                // Color based on class 0 probability
                const p0 = probs[0];
                const alpha = Math.abs(p0 - 0.5) * 0.6; // More transparent near decision boundary

                const color = p0 > 0.5 ?
                    `rgba(33, 150, 243, ${alpha})` :
                    `rgba(244, 67, 54, ${alpha})`;

                dataCtx.fillStyle = color;
                dataCtx.fillRect(x, y, resolution, resolution);
            }
        }

        // Draw decision boundary (where P(class 0) = P(class 1) = 0.5)
        dataCtx.strokeStyle = '#2d3748';
        dataCtx.lineWidth = 3;
        dataCtx.beginPath();
        let firstPoint = true;

        for (let x = 0; x < dataCanvas.width; x += 2) {
            for (let y = 0; y < dataCanvas.height; y += 2) {
                const dataX = x / dataCanvas.width;
                const dataY = 1 - y / dataCanvas.height;

                const probs = classifier.predictProba(dataX, dataY);

                // Check if we're near the decision boundary
                if (Math.abs(probs[0] - 0.5) < 0.02) {
                    if (firstPoint) {
                        dataCtx.moveTo(x, y);
                        firstPoint = false;
                    } else {
                        dataCtx.lineTo(x, y);
                    }
                }
            }
        }
        dataCtx.stroke();
    }

    // Draw grid
    dataCtx.strokeStyle = '#e2e8f0';
    dataCtx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
        const pos = (i / 10) * dataCanvas.width;
        dataCtx.beginPath();
        dataCtx.moveTo(pos, 0);
        dataCtx.lineTo(pos, dataCanvas.height);
        dataCtx.stroke();
    }
    for (let i = 0; i <= 10; i++) {
        const pos = (i / 10) * dataCanvas.height;
        dataCtx.beginPath();
        dataCtx.moveTo(0, pos);
        dataCtx.lineTo(dataCanvas.width, pos);
        dataCtx.stroke();
    }

    // Draw training data
    trainingData.forEach(point => {
        const x = point.x * dataCanvas.width;
        const y = (1 - point.y) * dataCanvas.height;

        dataCtx.fillStyle = point.label === 0 ? '#2196F3' : '#f44336';
        dataCtx.beginPath();
        dataCtx.arc(x, y, 6, 0, Math.PI * 2);
        dataCtx.fill();

        dataCtx.strokeStyle = '#fff';
        dataCtx.lineWidth = 2;
        dataCtx.stroke();
    });
}

function drawDistributions() {
    distCtx.clearRect(0, 0, distCanvas.width, distCanvas.height);

    if (!classifier) {
        distCtx.fillStyle = '#999';
        distCtx.font = '16px Arial';
        distCtx.textAlign = 'center';
        distCtx.fillText('Train classifier to see distributions', distCanvas.width / 2, distCanvas.height / 2);
        return;
    }

    const padding = 50;
    const width = (distCanvas.width - 3 * padding) / 2;
    const height = distCanvas.height - 2 * padding;

    // Draw X feature distributions
    drawFeatureDist(padding, padding, width, height, 'x', 'Feature X Distribution');

    // Draw Y feature distributions
    drawFeatureDist(padding * 2 + width, padding, width, height, 'y', 'Feature Y Distribution');
}

function drawFeatureDist(x, y, width, height, feature, title) {
    // Draw title
    distCtx.fillStyle = '#2d3748';
    distCtx.font = 'bold 14px Arial';
    distCtx.textAlign = 'center';
    distCtx.fillText(title, x + width / 2, y - 20);

    // Draw axes
    distCtx.strokeStyle = '#2d3748';
    distCtx.lineWidth = 2;
    distCtx.beginPath();
    distCtx.moveTo(x, y + height);
    distCtx.lineTo(x + width, y + height);
    distCtx.stroke();

    // Draw distributions for both classes
    const colors = ['#2196F3', '#f44336'];
    const classes = [0, 1];

    classes.forEach((cls, idx) => {
        const mean = classifier.means[cls][feature];
        const std = classifier.stds[cls][feature];

        distCtx.strokeStyle = colors[idx];
        distCtx.fillStyle = colors[idx] + '30';
        distCtx.lineWidth = 3;

        distCtx.beginPath();
        let firstPoint = true;

        for (let i = 0; i <= 100; i++) {
            const val = i / 100;
            const prob = classifier.gaussianPDF(val, mean, std);
            const maxProb = 1 / (std * Math.sqrt(2 * Math.PI));
            const normalizedProb = prob / maxProb;

            const px = x + val * width;
            const py = y + height - (normalizedProb * height * 0.8);

            if (firstPoint) {
                distCtx.moveTo(px, py);
                firstPoint = false;
            } else {
                distCtx.lineTo(px, py);
            }
        }

        distCtx.stroke();

        // Fill under curve
        distCtx.lineTo(x + width, y + height);
        distCtx.lineTo(x, y + height);
        distCtx.closePath();
        distCtx.fill();

        // Draw mean line
        const meanX = x + mean * width;
        distCtx.strokeStyle = colors[idx];
        distCtx.lineWidth = 2;
        distCtx.setLineDash([5, 5]);
        distCtx.beginPath();
        distCtx.moveTo(meanX, y);
        distCtx.lineTo(meanX, y + height);
        distCtx.stroke();
        distCtx.setLineDash([]);

        // Label
        distCtx.fillStyle = colors[idx];
        distCtx.font = 'bold 12px Arial';
        distCtx.textAlign = 'left';
        distCtx.fillText(`Class ${cls}: Œº=${mean.toFixed(2)}, œÉ=${std.toFixed(2)}`,
            x + 5, y + 20 + idx * 20);
    });
}

function updateStats() {
    document.getElementById('dataCount').textContent = trainingData.length;

    if (classifier) {
        document.getElementById('prior0').textContent = classifier.priors[0].toFixed(3);
        document.getElementById('prior1').textContent = classifier.priors[1].toFixed(3);

        // Calculate accuracy
        let correct = 0;
        trainingData.forEach(point => {
            const prediction = classifier.predict(point.x, point.y);
            if (prediction === point.label) correct++;
        });
        const accuracy = ((correct / trainingData.length) * 100).toFixed(1);
        document.getElementById('accuracy').textContent = accuracy + '%';
    } else {
        document.getElementById('prior0').textContent = '-';
        document.getElementById('prior1').textContent = '-';
        document.getElementById('accuracy').textContent = '-';
    }
}

function setDataClass(classNum) {
    currentClass = classNum;
    document.getElementById('class0Btn').classList.toggle('btn-active', classNum === 0);
    document.getElementById('class1Btn').classList.toggle('btn-active', classNum === 1);
}

function clearData() {
    trainingData = [];
    classifier = null;
    updateStats();
    drawDataCanvas();
    drawDistributions();
}

function loadDataset(type) {
    trainingData = [];

    switch(type) {
        case 'separated':
            for (let i = 0; i < 30; i++) {
                trainingData.push({
                    x: 0.2 + Math.random() * 0.2,
                    y: 0.5 + Math.random() * 0.4,
                    label: 0
                });
                trainingData.push({
                    x: 0.6 + Math.random() * 0.2,
                    y: 0.1 + Math.random() * 0.4,
                    label: 1
                });
            }
            break;

        case 'overlapping':
            for (let i = 0; i < 30; i++) {
                trainingData.push({
                    x: 0.3 + Math.random() * 0.3,
                    y: 0.4 + Math.random() * 0.4,
                    label: 0
                });
                trainingData.push({
                    x: 0.4 + Math.random() * 0.3,
                    y: 0.2 + Math.random() * 0.4,
                    label: 1
                });
            }
            break;

        case 'diagonal':
            for (let i = 0; i < 30; i++) {
                const x = Math.random();
                const y = Math.random();
                trainingData.push({
                    x: x,
                    y: y,
                    label: y > x ? 0 : 1
                });
            }
            break;

        case 'clusters':
            for (let i = 0; i < 25; i++) {
                trainingData.push({
                    x: 0.25 + Math.random() * 0.15,
                    y: 0.7 + Math.random() * 0.15,
                    label: 0
                });
                trainingData.push({
                    x: 0.7 + Math.random() * 0.15,
                    y: 0.25 + Math.random() * 0.15,
                    label: 1
                });
            }
            break;
    }

    trainClassifier();
}

// Mouse move handler for probability display
dataCanvas.addEventListener('mousemove', (e) => {
    if (!classifier) return;

    const rect = dataCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / dataCanvas.width;
    const y = 1 - (e.clientY - rect.top) / dataCanvas.height;

    const probs = classifier.predictProba(x, y);

    document.getElementById('probDisplay').style.display = 'block';
    document.getElementById('prob0').textContent = (probs[0] * 100).toFixed(1) + '%';
    document.getElementById('prob1').textContent = (probs[1] * 100).toFixed(1) + '%';
});

dataCanvas.addEventListener('mouseleave', () => {
    document.getElementById('probDisplay').style.display = 'none';
});

dataCanvas.addEventListener('click', (e) => {
    const rect = dataCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / dataCanvas.width;
    const y = 1 - (e.clientY - rect.top) / dataCanvas.height;

    trainingData.push({
        x: x,
        y: y,
        label: currentClass
    });

    updateStats();
    drawDataCanvas();
});

// Initialize
drawDataCanvas();
drawDistributions();
updateStats();
</script>
</body>
</html>
