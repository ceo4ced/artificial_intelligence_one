<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GAN Training Visualizer - Deep Learning Tool</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    padding: 0;
}

.nav-header {
    background: #2d3748;
    padding: 15px 30px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.nav-header a {
    color: #90cdf4;
    text-decoration: none;
    font-weight: 600;
    font-size: 1.1em;
    transition: color 0.3s;
    margin-left: 15px;
}

.nav-header a:hover {
    color: #63b3ed;
}

.nav-title {
    color: #fff;
    font-size: 1.2em;
    font-weight: 700;
}

.nav-links {
    display: flex;
    gap: 10px;
}

.page-wrapper {
    padding: 20px;
}

.container {
    max-width: 1600px;
    margin: 0 auto;
    background: #fff;
    border-radius: 15px;
    padding: 30px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}

h1 {
    text-align: center;
    color: #2d3748;
    margin-bottom: 10px;
    font-size: 2.5em;
}

.subtitle {
    text-align: center;
    color: #4a5568;
    margin-bottom: 30px;
    font-size: 1.1em;
}

.info-section {
    background: #e8f5e9;
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 25px;
    border-left: 5px solid #4CAF50;
}

.info-section h3 {
    color: #2e7d32;
    margin-bottom: 10px;
}

.info-section p {
    color: #1b5e20;
    line-height: 1.6;
    margin-bottom: 8px;
}

.info-section ul {
    list-style-position: inside;
    color: #1b5e20;
    line-height: 1.8;
}

.main-content {
    display: grid;
    grid-template-columns: 320px 1fr;
    gap: 30px;
    margin-bottom: 30px;
}

.sidebar {
    background: #f8f9fa;
    padding: 20px;
    border-radius: 10px;
    height: fit-content;
}

.sidebar h3 {
    color: #2d3748;
    margin-bottom: 15px;
    font-size: 1.3em;
}

.control-section {
    margin-bottom: 20px;
}

.control-section label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #4a5568;
}

button {
    width: 100%;
    padding: 12px;
    font-size: 14px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 10px;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

.btn-primary {
    background: #4CAF50;
    color: #fff;
}

.btn-primary:hover {
    background: #45a049;
}

.btn-secondary {
    background: #2196F3;
    color: #fff;
}

.btn-secondary:hover {
    background: #0b7dda;
}

.btn-danger {
    background: #f44336;
    color: #fff;
}

.btn-danger:hover {
    background: #da190b;
}

.btn-warning {
    background: #ff9800;
    color: #fff;
}

.btn-warning:hover {
    background: #e68900;
}

.slider-control {
    width: 100%;
    margin-bottom: 10px;
}

.slider-value {
    text-align: center;
    font-weight: 600;
    color: #667eea;
    margin-bottom: 10px;
    font-size: 1.1em;
}

.status-indicator {
    background: #e3f2fd;
    padding: 10px;
    border-radius: 6px;
    margin-bottom: 15px;
    font-size: 0.9em;
    color: #1565c0;
    font-weight: 600;
    text-align: center;
}

.stats-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    margin-top: 20px;
}

.stat-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #fff;
    padding: 12px;
    border-radius: 10px;
    text-align: center;
}

.stat-label {
    font-size: 0.85em;
    opacity: 0.9;
    margin-bottom: 5px;
}

.stat-value {
    font-size: 1.5em;
    font-weight: bold;
}

.visualization-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
}

.viz-box {
    background: #f8f9fa;
    border-radius: 10px;
    padding: 15px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.viz-box h3 {
    color: #2d3748;
    margin-bottom: 15px;
    font-size: 1.2em;
    text-align: center;
}

canvas {
    display: block;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    background: #fafafa;
    margin: 0 auto;
}

.legend {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 10px;
    font-size: 0.9em;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
}

.legend-color {
    width: 20px;
    height: 20px;
    border-radius: 4px;
    border: 1px solid #333;
}

@media (max-width: 1400px) {
    .main-content {
        grid-template-columns: 1fr;
    }

    .visualization-grid {
        grid-template-columns: 1fr;
    }
}
</style>
</head>
<body>
<nav class="nav-header">
    <div class="nav-title">GAN Training Visualizer</div>
    <div class="nav-links">
        <a href="../../deep-learning.html">Deep Learning Hub</a>
        <a href="../../index.html">Home</a>
    </div>
</nav>

<div class="page-wrapper">
    <div class="container">
        <h1>GAN Training Visualizer</h1>
        <p class="subtitle">Watch Generator and Discriminator compete to create realistic data!</p>

        <div class="info-section">
            <h3>What is a GAN?</h3>
            <p>
                Generative Adversarial Networks (GANs) consist of two neural networks competing against each other:
                the Generator tries to create fake data, while the Discriminator tries to distinguish real from fake.
                Through this competition, the Generator learns to create increasingly realistic data.
            </p>
            <p><strong>Key concepts:</strong></p>
            <ul>
                <li><strong>Generator:</strong> Creates fake data from random noise, trying to fool the discriminator</li>
                <li><strong>Discriminator:</strong> Classifies data as real or fake, trying to catch the generator</li>
                <li><strong>Adversarial Training:</strong> Both networks improve by competing against each other</li>
                <li><strong>Nash Equilibrium:</strong> The ideal state where neither can improve further</li>
                <li><strong>Mode Collapse:</strong> When the generator produces limited variety of outputs</li>
            </ul>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <h3>Controls</h3>

                <div class="status-indicator" id="statusIndicator">
                    Ready to train
                </div>

                <div class="control-section">
                    <label>Training Speed:</label>
                    <div class="slider-value" id="speedValue">Medium</div>
                    <input type="range" class="slider-control" id="speedSlider"
                           min="1" max="3" step="1" value="2"
                           oninput="updateSpeed()">
                </div>

                <div class="control-section">
                    <label>Generator Learning Rate:</label>
                    <div class="slider-value" id="genLrValue">0.001</div>
                    <input type="range" class="slider-control" id="genLrSlider"
                           min="0.0001" max="0.01" step="0.0001" value="0.001"
                           oninput="updateGenLr()">
                </div>

                <div class="control-section">
                    <label>Discriminator Learning Rate:</label>
                    <div class="slider-value" id="discLrValue">0.001</div>
                    <input type="range" class="slider-control" id="discLrSlider"
                           min="0.0001" max="0.01" step="0.0001" value="0.001"
                           oninput="updateDiscLr()">
                </div>

                <button class="btn-primary" onclick="startTraining()">Start Training</button>
                <button class="btn-warning" onclick="pauseTraining()">Pause</button>
                <button class="btn-danger" onclick="resetGAN()">Reset</button>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">Epoch</div>
                        <div class="stat-value" id="epochValue">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Generator Loss</div>
                        <div class="stat-value" id="genLossValue">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Discriminator Loss</div>
                        <div class="stat-value" id="discLossValue">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Discriminator Accuracy</div>
                        <div class="stat-value" id="discAccValue">-</div>
                    </div>
                </div>
            </div>

            <div>
                <div class="visualization-grid">
                    <div class="viz-box">
                        <h3>Data Distribution</h3>
                        <canvas id="dataCanvas" width="450" height="400"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #2196F3;"></div>
                                <span>Real Data</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #f44336;"></div>
                                <span>Generated (Fake)</span>
                            </div>
                        </div>
                    </div>

                    <div class="viz-box">
                        <h3>Loss Over Time</h3>
                        <canvas id="lossCanvas" width="450" height="400"></canvas>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #4CAF50;"></div>
                                <span>Generator Loss</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #ff9800;"></div>
                                <span>Discriminator Loss</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="viz-box">
                    <h3>GAN Architecture</h3>
                    <canvas id="architectureCanvas" width="950" height="300"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
const dataCanvas = document.getElementById('dataCanvas');
const dataCtx = dataCanvas.getContext('2d');
const lossCanvas = document.getElementById('lossCanvas');
const lossCtx = lossCanvas.getContext('2d');
const archCanvas = document.getElementById('architectureCanvas');
const archCtx = archCanvas.getContext('2d');

let epoch = 0;
let isTraining = false;
let trainingInterval = null;
let animationSpeed = 100;

let genLearningRate = 0.001;
let discLearningRate = 0.001;

// Real data distribution (Gaussian)
let realData = [];

// Generated data
let generatedData = [];

// Loss history
let genLossHistory = [];
let discLossHistory = [];

// Generator state (mean and std of distribution it's trying to learn)
let genMean = 5;
let genStd = 3;

// Discriminator accuracy
let discAccuracy = 0.5;

function initializeData() {
    // Generate real data (Gaussian centered at 15)
    realData = [];
    for (let i = 0; i < 200; i++) {
        realData.push(gaussianRandom(15, 2));
    }

    // Initialize generator with poor distribution
    genMean = 5;
    genStd = 3;
    updateGeneratedData();

    genLossHistory = [];
    discLossHistory = [];
    epoch = 0;
}

function gaussianRandom(mean, std) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mean + std * z;
}

function updateGeneratedData() {
    generatedData = [];
    for (let i = 0; i < 200; i++) {
        generatedData.push(gaussianRandom(genMean, genStd));
    }
}

function trainStep() {
    // Simulate discriminator training
    // Discriminator learns to distinguish real from fake
    const realSamples = realData.slice(0, 32);
    const fakeSamples = generatedData.slice(0, 32);

    // Calculate how well discriminator can distinguish
    let correctReal = 0;
    let correctFake = 0;

    realSamples.forEach(sample => {
        // Probability discriminator thinks it's real
        const prob = 1 / (1 + Math.exp(-(sample - genMean)));
        if (prob > 0.5) correctReal++;
    });

    fakeSamples.forEach(sample => {
        const prob = 1 / (1 + Math.exp(-(sample - genMean)));
        if (prob <= 0.5) correctFake++;
    });

    discAccuracy = (correctReal + correctFake) / 64;

    // Discriminator loss (binary cross-entropy)
    const discLoss = -Math.log(discAccuracy + 0.01);

    // Generator loss (tries to fool discriminator)
    const genLoss = -Math.log(1 - discAccuracy + 0.01);

    // Update generator to move toward real distribution
    const error = 15 - genMean;
    genMean += error * genLearningRate * 100;

    const stdError = 2 - genStd;
    genStd += stdError * genLearningRate * 50;

    // Constrain values
    genStd = Math.max(0.5, Math.min(5, genStd));
    genMean = Math.max(0, Math.min(20, genMean));

    updateGeneratedData();

    // Record losses
    genLossHistory.push(genLoss);
    discLossHistory.push(discLoss);

    // Keep only last 50 epochs
    if (genLossHistory.length > 50) {
        genLossHistory.shift();
        discLossHistory.shift();
    }

    epoch++;
    updateStats();
    drawAll();
}

function drawDataDistribution() {
    dataCtx.clearRect(0, 0, dataCanvas.width, dataCanvas.height);

    const padding = 40;
    const width = dataCanvas.width - 2 * padding;
    const height = dataCanvas.height - 2 * padding;

    // Draw axes
    dataCtx.strokeStyle = '#2d3748';
    dataCtx.lineWidth = 2;
    dataCtx.beginPath();
    dataCtx.moveTo(padding, padding);
    dataCtx.lineTo(padding, padding + height);
    dataCtx.lineTo(padding + width, padding + height);
    dataCtx.stroke();

    // Create histograms
    const bins = 30;
    const binWidth = 25 / bins;
    const realHist = new Array(bins).fill(0);
    const fakeHist = new Array(bins).fill(0);

    realData.forEach(val => {
        const bin = Math.floor(val / binWidth);
        if (bin >= 0 && bin < bins) realHist[bin]++;
    });

    generatedData.forEach(val => {
        const bin = Math.floor(val / binWidth);
        if (bin >= 0 && bin < bins) fakeHist[bin]++;
    });

    const maxCount = Math.max(...realHist, ...fakeHist);

    // Draw real data histogram
    dataCtx.fillStyle = 'rgba(33, 150, 243, 0.5)';
    realHist.forEach((count, i) => {
        const x = padding + (i / bins) * width;
        const barHeight = (count / maxCount) * height;
        const y = padding + height - barHeight;
        dataCtx.fillRect(x, y, width / bins - 1, barHeight);
    });

    // Draw fake data histogram
    dataCtx.fillStyle = 'rgba(244, 67, 54, 0.5)';
    fakeHist.forEach((count, i) => {
        const x = padding + (i / bins) * width;
        const barHeight = (count / maxCount) * height;
        const y = padding + height - barHeight;
        dataCtx.fillRect(x, y, width / bins - 1, barHeight);
    });

    // Labels
    dataCtx.fillStyle = '#2d3748';
    dataCtx.font = 'bold 12px Arial';
    dataCtx.textAlign = 'center';
    dataCtx.fillText('Value', padding + width / 2, padding + height + 30);

    dataCtx.save();
    dataCtx.translate(15, padding + height / 2);
    dataCtx.rotate(-Math.PI / 2);
    dataCtx.fillText('Frequency', 0, 0);
    dataCtx.restore();
}

function drawLossChart() {
    lossCtx.clearRect(0, 0, lossCanvas.width, lossCanvas.height);

    if (genLossHistory.length === 0) return;

    const padding = 40;
    const width = lossCanvas.width - 2 * padding;
    const height = lossCanvas.height - 2 * padding;

    // Draw axes
    lossCtx.strokeStyle = '#2d3748';
    lossCtx.lineWidth = 2;
    lossCtx.beginPath();
    lossCtx.moveTo(padding, padding);
    lossCtx.lineTo(padding, padding + height);
    lossCtx.lineTo(padding + width, padding + height);
    lossCtx.stroke();

    const maxLoss = Math.max(...genLossHistory, ...discLossHistory, 5);

    // Draw generator loss
    lossCtx.strokeStyle = '#4CAF50';
    lossCtx.lineWidth = 3;
    lossCtx.beginPath();

    genLossHistory.forEach((loss, i) => {
        const x = padding + (i / (genLossHistory.length - 1)) * width;
        const y = padding + height - (loss / maxLoss) * height;

        if (i === 0) lossCtx.moveTo(x, y);
        else lossCtx.lineTo(x, y);
    });
    lossCtx.stroke();

    // Draw discriminator loss
    lossCtx.strokeStyle = '#ff9800';
    lossCtx.lineWidth = 3;
    lossCtx.beginPath();

    discLossHistory.forEach((loss, i) => {
        const x = padding + (i / (discLossHistory.length - 1)) * width;
        const y = padding + height - (loss / maxLoss) * height;

        if (i === 0) lossCtx.moveTo(x, y);
        else lossCtx.lineTo(x, y);
    });
    lossCtx.stroke();

    // Labels
    lossCtx.fillStyle = '#2d3748';
    lossCtx.font = 'bold 12px Arial';
    lossCtx.textAlign = 'center';
    lossCtx.fillText('Epoch', padding + width / 2, padding + height + 30);

    lossCtx.save();
    lossCtx.translate(15, padding + height / 2);
    lossCtx.rotate(-Math.PI / 2);
    lossCtx.fillText('Loss', 0, 0);
    lossCtx.restore();
}

function drawArchitecture() {
    archCtx.clearRect(0, 0, archCanvas.width, archCanvas.height);

    const y = archCanvas.height / 2;

    // Noise input
    drawBox(archCtx, 50, y - 40, 80, 80, '#9C27B0', 'Random\nNoise');

    // Arrow
    drawArrow(archCtx, 130, y, 200, y);

    // Generator
    drawBox(archCtx, 200, y - 50, 120, 100, '#4CAF50', 'Generator\nNetwork');

    // Arrow
    drawArrow(archCtx, 320, y, 390, y);

    // Fake data
    drawBox(archCtx, 390, y - 40, 80, 80, '#f44336', 'Fake\nData');

    // Real data
    drawBox(archCtx, 390, y - 160, 80, 80, '#2196F3', 'Real\nData');

    // Arrows to discriminator
    drawArrow(archCtx, 470, y, 540, y);
    drawArrow(archCtx, 430, y - 120, 540, y - 40);

    // Discriminator
    drawBox(archCtx, 540, y - 50, 120, 100, '#ff9800', 'Discriminator\nNetwork');

    // Arrow
    drawArrow(archCtx, 660, y, 730, y);

    // Output
    drawBox(archCtx, 730, y - 40, 100, 80, '#667eea', 'Real or\nFake?');

    // Feedback arrows
    archCtx.strokeStyle = '#666';
    archCtx.setLineDash([5, 5]);
    archCtx.lineWidth = 2;

    // Generator feedback
    archCtx.beginPath();
    archCtx.moveTo(730, y + 50);
    archCtx.lineTo(730, y + 80);
    archCtx.lineTo(260, y + 80);
    archCtx.lineTo(260, y + 50);
    archCtx.stroke();

    archCtx.fillStyle = '#666';
    archCtx.font = '11px Arial';
    archCtx.textAlign = 'center';
    archCtx.fillText('Generator learns from discriminator feedback', 400, y + 95);

    archCtx.setLineDash([]);
}

function drawBox(ctx, x, y, w, h, color, text) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, w, h);

    ctx.strokeStyle = '#2d3748';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, w, h);

    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const lines = text.split('\n');
    lines.forEach((line, i) => {
        ctx.fillText(line, x + w/2, y + h/2 + (i - lines.length/2 + 0.5) * 16);
    });
}

function drawArrow(ctx, x1, y1, x2, y2) {
    ctx.strokeStyle = '#2d3748';
    ctx.fillStyle = '#2d3748';
    ctx.lineWidth = 2;
    ctx.setLineDash([]);

    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    // Arrowhead
    const angle = Math.atan2(y2 - y1, x2 - x1);
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - 10 * Math.cos(angle - Math.PI/6), y2 - 10 * Math.sin(angle - Math.PI/6));
    ctx.lineTo(x2 - 10 * Math.cos(angle + Math.PI/6), y2 - 10 * Math.sin(angle + Math.PI/6));
    ctx.closePath();
    ctx.fill();
}

function drawAll() {
    drawDataDistribution();
    drawLossChart();
    drawArchitecture();
}

function updateStats() {
    document.getElementById('epochValue').textContent = epoch;

    if (genLossHistory.length > 0) {
        const genLoss = genLossHistory[genLossHistory.length - 1];
        const discLoss = discLossHistory[discLossHistory.length - 1];

        document.getElementById('genLossValue').textContent = genLoss.toFixed(3);
        document.getElementById('discLossValue').textContent = discLoss.toFixed(3);
        document.getElementById('discAccValue').textContent = (discAccuracy * 100).toFixed(1) + '%';
    }
}

function updateSpeed() {
    const speed = parseInt(document.getElementById('speedSlider').value);
    const speeds = { 1: 'Slow', 2: 'Medium', 3: 'Fast' };
    const delays = { 1: 200, 2: 100, 3: 50 };

    document.getElementById('speedValue').textContent = speeds[speed];
    animationSpeed = delays[speed];

    if (isTraining) {
        pauseTraining();
        startTraining();
    }
}

function updateGenLr() {
    genLearningRate = parseFloat(document.getElementById('genLrSlider').value);
    document.getElementById('genLrValue').textContent = genLearningRate.toFixed(4);
}

function updateDiscLr() {
    discLearningRate = parseFloat(document.getElementById('discLrSlider').value);
    document.getElementById('discLrValue').textContent = discLearningRate.toFixed(4);
}

function startTraining() {
    if (isTraining) return;

    isTraining = true;

    document.getElementById('statusIndicator').textContent = 'Training...';
    document.getElementById('statusIndicator').style.background = '#d4edda';
    document.getElementById('statusIndicator').style.color = '#155724';

    trainingInterval = setInterval(() => {
        trainStep();
    }, animationSpeed);
}

function pauseTraining() {
    isTraining = false;

    if (trainingInterval) {
        clearInterval(trainingInterval);
        trainingInterval = null;
    }

    document.getElementById('statusIndicator').textContent = 'Paused';
    document.getElementById('statusIndicator').style.background = '#fff3cd';
    document.getElementById('statusIndicator').style.color = '#856404';
}

function resetGAN() {
    pauseTraining();
    initializeData();
    updateStats();
    drawAll();

    document.getElementById('statusIndicator').textContent = 'Reset - Ready to train';
    document.getElementById('statusIndicator').style.background = '#e3f2fd';
    document.getElementById('statusIndicator').style.color = '#1565c0';
}

// Initialize
initializeData();
drawAll();
updateStats();
</script>
</body>
</html>
